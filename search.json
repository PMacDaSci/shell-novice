[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Unix Shell",
    "section": "",
    "text": "This workshop introduces the Unix shell (Bash) as a practical tool for working with files, automating repetitive tasks, and building reproducible workflows. You will learn how the shell relates to your operating system and applications, and how to efficiently navigate directories, inspect and manipulate files, chain commands with pipes and filters, iterate with loops, and write simple shell scripts. By the end, you’ll be comfortable using core command-line patterns to explore data, transform text, and compose small, simple pipelines."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "The Unix Shell",
    "section": "",
    "text": "This workshop introduces the Unix shell (Bash) as a practical tool for working with files, automating repetitive tasks, and building reproducible workflows. You will learn how the shell relates to your operating system and applications, and how to efficiently navigate directories, inspect and manipulate files, chain commands with pipes and filters, iterate with loops, and write simple shell scripts. By the end, you’ll be comfortable using core command-line patterns to explore data, transform text, and compose small, simple pipelines."
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "The Unix Shell",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this workshop, you will know how to:\n\nUnderstand what the shell is and when to use it.\nMove around folders and find your way to files.\nMake, copy, rename, and delete files and folders.\nJoin simple commands together to get the result you want.\nRepeat actions on many files without retyping.\nSave steps in small scripts so you can reuse them.\nSearch for files and for text inside files quickly."
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "The Unix Shell",
    "section": "Prerequisites",
    "text": "Prerequisites\nThis lesson guides you through the basics of file systems and the shell. If you have stored files on a computer at all and recognize the word “file” and either “directory” or “folder” (two common words for the same thing), you’re ready for this lesson.\nIf you’re already comfortable manipulating files and directories, searching for files with grep and find, and writing simple loops and scripts, you probably want to skip this workshop."
  },
  {
    "objectID": "index.html#course-outline",
    "href": "index.html#course-outline",
    "title": "The Unix Shell",
    "section": "Course Outline",
    "text": "Course Outline\n\n\n\n\nTime\n\n\nLesson\n\n\nQuestions\n\n\n\n\n5\n\n\nIntroducing the Shell\n\n\nWhat is a command shell and why would I use one?\n\n\n\n\n30\n\n\nNavigating Files and Directories\n\n\nHow can I move around on my computer?How can I see what files and directories I have?How can I specify the location of a file or directory on my computer?\n\n\n\n\n30\n\n\nWorking With Files and Directories\n\n\nHow can I create, copy, and delete files and directories?How can I edit files?\n\n\n\n\n10\n\n\nFile Permissions\n\n\nHow do file and directory permissions work?\n\n\n\n\n25\n\n\nPipes and Filters\n\n\nHow can I combine existing commands to produce a desired output?How can I show only part of the output?\n\n\n\n\n40\n\n\nLoops\n\n\nHow can I perform the same actions on many different files?\n\n\n\n\n30\n\n\nShell Scripts\n\n\nHow can I save and re-use commands?\n\n\n\n\n25\n\n\nFinding Things\n\n\nHow can I find files?How can I find things in files?\n\n\n\n\n20\n\n\nAWK for Text Processing\n\n\nHow do I print specific columns from a text table?How can I use patterns to select only certain lines in a file?How do I count lines or matched lines in a file?"
  },
  {
    "objectID": "index.html#credits-and-acknowledgement",
    "href": "index.html#credits-and-acknowledgement",
    "title": "The Unix Shell",
    "section": "Credits and Acknowledgement",
    "text": "Credits and Acknowledgement\nThese content were adapted from the following course materials:\n\nThe Carpentries Incubator - The Unix Shell"
  },
  {
    "objectID": "episodes/02-filedir.html",
    "href": "episodes/02-filedir.html",
    "title": "Navigating Files and Directories",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 30\nExercises: 10\nQuestions:\n\nHow can I move around on my computer?\nHow can I see what files and directories I have?\nHow can I specify the location of a file or directory on my computer?\n\nObjectives:\n\nExplain the similarities and differences between a file and a directory.\nTranslate an absolute path into a relative path and vice versa.\nConstruct absolute and relative paths that identify specific files and directories.\nUse options and arguments to change the behaviour of a shell command.\nDemonstrate the use of tab completion and explain its advantages.\nThe part of the operating system responsible for managing files and directories is called the file system. It organizes our data into files, which hold information, and directories (also called ‘folders’), which hold files or other directories.\nSeveral commands are frequently used to create, inspect, rename, and delete files and directories. To start exploring them, we’ll go to our open shell window.\nFirst, let’s find out where we are by running a command called pwd (which stands for ‘print working directory’). Directories are like places — at any time while we are using the shell, we are in exactly one place called our current working directory. Commands mostly read and write files in the current working directory, i.e. ‘here’, so knowing where you are before running a command is important. pwd shows you where you are:\nHere, the computer’s response is /Users/nelle, which is Nelle’s home directory:\nTo understand what a ‘home directory’ is, let’s have a look at how the file system as a whole is organized. For the sake of this example, we’ll be illustrating the filesystem on our scientist Nelle’s computer. After this illustration, you’ll be learning commands to explore your own filesystem, which will be constructed in a similar way, but not be exactly identical.\nOn Nelle’s computer, the filesystem looks like this:\nThe filesystem looks like an upside down tree. The topmost directory is the root directory that holds everything else. We refer to it using a slash character, /, on its own; this character is the leading slash in /Users/nelle.\nInside that directory are several other directories: bin (which is where some built-in programs are stored), data (for miscellaneous data files), Users (where users’ personal directories are located), tmp (for temporary files that don’t need to be stored long-term), and so on.\nWe know that our current working directory /Users/nelle is stored inside /Users because /Users is the first part of its name. Similarly, we know that /Users is stored inside the root directory / because its name begins with /.\nUnderneath /Users, we find one directory for each user with an account on Nelle’s machine, her colleagues imhotep and larry.\nThe user imhotep’s files are stored in /Users/imhotep, user larry’s in /Users/larry, and Nelle’s in /Users/nelle. Nelle is the user in our examples here; therefore, we get /Users/nelle as our home directory. Typically, when you open a new command prompt, you will be in your home directory to start.\nNow let’s learn the command that will let us see the contents of our own filesystem. We can see what’s in our home directory by running ls:\n(Again, your results may be slightly different depending on your operating system and how you have customized your filesystem.)\nls prints the names of the files and directories in the current directory. We can make its output more comprehensible by using the -F option which tells ls to classify the output by adding a marker to file and directory names to indicate what they are:\nDepending on your shell’s default settings, the shell might also use colors to indicate whether each entry is a file or directory.\nHere, we can see that the home directory contains only sub-directories. Any names in the output that don’t have a classification symbol are files in the current working directory."
  },
  {
    "objectID": "episodes/02-filedir.html#general-syntax-of-a-shell-command",
    "href": "episodes/02-filedir.html#general-syntax-of-a-shell-command",
    "title": "Navigating Files and Directories",
    "section": "General Syntax of a Shell Command",
    "text": "General Syntax of a Shell Command\nWe have now encountered commands, options, and arguments, but it is perhaps useful to formalise some terminology.\nConsider the command below as a general example of a command, which we will dissect into its component parts:\n$ ls -F /\n\n\n\n\n\nls is the command, with an option -F and an argument /. We’ve already encountered options which either start with a single dash (-), known as short options, or two dashes (--), known as long options. Options change the behavior of a command and Arguments tell the command what to operate on (e.g. files and directories). Sometimes options and arguments are referred to as parameters. A command can be called with more than one option and more than one argument, but a command doesn’t always require an argument or an option.\nYou might sometimes see options being referred to as switches or flags, especially for options that take no argument. In this lesson we will stick with using the term option.\nEach part is separated by spaces. If you omit the space between ls and -F the shell will look for a command called ls-F, which doesn’t exist. Also, capitalization can be important. For example, ls -s will display the size of files and directories alongside the names, while ls -S will sort the files and directories by size, as shown below:\n$ cd ~/Desktop/shell-lesson-data\n$ ls -s exercise-data\ntotal 28\n 4 animal-counts   4 creatures  12 numbers.txt   4 alkanes   4 writing\nNote that the sizes returned by ls -s are in blocks. As these are defined differently for different operating systems, you may not obtain the same figures as in the example.\n$ ls -S exercise-data\nanimal-counts  creatures  alkanes  writing  numbers.txt\nPutting all that together, our command ls -F / above gives us a listing of files and directories in the root directory /. An example of the output you might get from the above command is given below:\n$ ls -F /\nApplications/         System/\nLibrary/              Users/\nNetwork/              Volumes/\n\nNelle’s Pipeline: Organizing Files\nKnowing this much about files and directories, Nelle is ready to organize the files that the protein assay machine will create.\nShe creates a directory called north-pacific-gyre (to remind herself where the data came from), which will contain the data files from the assay machine and her data processing scripts.\nEach of her physical samples is labelled according to her lab’s convention with a unique ten-character ID, such as ‘NENE01729A’. This ID is what she used in her collection log to record the location, time, depth, and other characteristics of the sample, so she decides to use it within the filename of each data file. Since the output of the assay machine is plain text, she will call her files NENE01729A.txt, NENE01812A.txt, and so on. All 1520 files will go into the same directory.\nNow in her current directory shell-lesson-data, Nelle can see what files she has using the command:\n$ ls north-pacific-gyre/\nThis command is a lot to type, but she can let the shell do most of the work through what is called tab completion. If she types:\n$ ls nor\nand then presses Tab (the tab key on her keyboard), the shell automatically completes the directory name for her:\n$ ls north-pacific-gyre/\nPressing Tab again does nothing, since there are multiple possibilities; pressing Tab twice brings up a list of all the files.\nIf Nelle then presses G and then presses Tab again, the shell will append ‘goo’ since all files that start with ‘g’ share the first three characters ‘goo’.\n$ ls north-pacific-gyre/goo\nTo see all of those files, she can press Tab twice more.\nls north-pacific-gyre/goo\ngoodiff.sh   goostats.sh\nThis is called tab completion, and we will see it in many other tools as we go on.\n\n\n\n\n\n\nKey Points\n\n\n\n\nThe file system is responsible for managing information on the disk.\nInformation is stored in files, which are stored in directories (folders).\nDirectories can also store other directories, which then form a directory tree.\npwd prints the user’s current working directory.\nls [path] prints a listing of a specific file or directory; ls on its own lists the current working directory.\ncd [path] changes the current working directory.\nMost commands take options that begin with a single -.\nDirectory names in a path are separated with / on Unix, but \\ on Windows.\n/ on its own is the root directory of the whole file system.\nAn absolute path specifies a location from the root of the file system.\nA relative path specifies a location starting from the current location.\n. on its own means ‘the current directory’; .. means ‘the directory above the current one’.\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/03-create.html",
    "href": "episodes/03-create.html",
    "title": "Working With Files and Directories",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 30\nExercises: 20\nQuestions:\n\nHow can I create, copy, and delete files and directories?\nHow can I edit files?\n\nObjectives:\n\nDelete, copy and move specified files and/or directories.\nCreate files in that hierarchy using an editor or by copying and renaming existing files.\nCreate a directory hierarchy that matches a given diagram."
  },
  {
    "objectID": "episodes/03-create.html#creating-directories",
    "href": "episodes/03-create.html#creating-directories",
    "title": "Working With Files and Directories",
    "section": "Creating directories",
    "text": "Creating directories\nWe now know how to explore files and directories, but how do we create them in the first place?\nIn this episode we will learn about creating and moving files and directories, using the exercise-data/writing directory as an example.\n\nStep one: see where we are and what we already have\nWe should still be in the shell-lesson-data directory on the Desktop, which we can check using:\n$ pwd\n/Users/nelle/Desktop/shell-lesson-data\nNext we’ll move to the exercise-data/writing directory and see what it contains:\n$ cd exercise-data/writing/\n$ ls -F\nhaiku.txt  LittleWomen.txt\n\n\nCreate a directory\nLet’s create a new directory called thesis using the command mkdir thesis (which has no output):\n$ mkdir thesis\nAs you might guess from its name, mkdir means ‘make directory’. Since thesis is a relative path (i.e., does not have a leading slash, like /what/ever/thesis), the new directory is created in the current working directory:\n$ ls -F\nhaiku.txt  LittleWomen.txt  thesis/\nSince we’ve just created the thesis directory, there’s nothing in it yet:\n$ ls -F thesis\nNote that mkdir is not limited to creating single directories one at a time. The -p option allows mkdir to create a directory with nested subdirectories in a single operation:\n$ mkdir -p ../project/data ../project/results\nThe -R option to the ls command will list all nested subdirectories within a directory. Let’s use ls -FR to recursively list the new directory hierarchy we just created in the project directory:\n$ ls -FR ../project\n../project/:\ndata/  results/\n\n../project/data:\n\n../project/results:\n\n\n\n\n\n\nTwo ways of doing the same thing\n\n\n\nUsing the shell to create a directory is no different than using a file explorer. If you open the current directory using your operating system’s graphical file explorer, the thesis directory will appear there too. While the shell and the file explorer are two different ways of interacting with the files, the files and directories themselves are the same.\n\n\n\n\n\n\n\n\nGood names for files and directories\n\n\n\nComplicated names of files and directories can make your life painful when working on the command line. Here we provide a few useful tips for the names of your files and directories.\n\nDon’t use spaces.\n\nSpaces can make a name more meaningful, but since spaces are used to separate arguments on the command line it is better to avoid them in names of files and directories. You can use - or _ instead (e.g. north-pacific-gyre/ rather than north pacific gyre/). To test this out, try typing mkdir north pacific gyre and see what directory (or directories!) are made when you check with ls -F.\n\nDon’t begin the name with - (dash).\n\nCommands treat names starting with - as options.\n\nStick with lowercase letters, numbers, . (period or ‘full stop’), - (dash) and _ (underscore).\n\nMany other characters have special meanings on the command line. We will learn about some of these during this lesson. There are special characters that can cause your command to not work as expected and can even result in data loss.\nIf you need to refer to names of files or directories that have spaces or other special characters, you should surround the name in single quotes ('').\nIt is often good practice to use all lowercase letters in names of files and directories; Windows and macOS file systems are typically case insensitive and therefore unable to distinguish between thesis and Thesis in the same directory.\n\n\n\n\nCreate a text file\nLet’s change our working directory to thesis using cd, then run a text editor called Nano to create a file called draft.txt:\n$ cd thesis\n$ nano draft.txt\n\n\n\n\n\n\nWhich Editor?\n\n\n\nWhen we say, ‘nano is a text editor’ we really do mean ‘text’. It can only work with plain character data, not tables, images, or any other human-friendly media. We use it in examples because it is one of the least complex text editors. However, because of this trait, it may not be powerful enough or flexible enough for the work you need to do after this workshop. On Unix systems (such as Linux and macOS), many programmers use Emacs or Vim (both of which require more time to learn), or a graphical editor such as Gedit or VScode. On Windows, you may wish to use Notepad++. Windows also has a built-in editor called notepad that can be run from the command line in the same way as nano for the purposes of this lesson.\nNo matter what editor you use, you will need to know where it searches for and saves files. If you start it from the shell, it will (probably) use your current working directory as its default location. If you use your computer’s start menu, it may want to save files in your Desktop or Documents directory instead. You can change this by navigating to another directory the first time you ‘Save As…’\n\n\nLet’s type in a few lines of text.\n\nOnce we’re happy with our text, we can press Ctrl+O (press the Ctrl or Control key and, while holding it down, press the O key) to write our data to disk. We will be asked to provide a name for the file that will contain our text. Press Return to accept the suggested default of draft.txt.\nOnce our file is saved, we can use Ctrl+X to quit the editor and return to the shell.\n\n\n\n\n\n\nControl, Ctrl, or ^ Key\n\n\n\nThe Control key is also called the ‘Ctrl’ key. There are various ways in which using the Control key may be described. For example, you may see an instruction to press the Control key and, while holding it down, press the X key, described as any of:\n\nControl-X\nControl+X\nCtrl-X\nCtrl+X\n^X\nC-x\n\nIn nano, along the bottom of the screen you’ll see ^G Get Help ^O WriteOut. This means that you can use Control-G to get help and Control-O to save your file.\n\n\nnano doesn’t leave any output on the screen after it exits, but ls now shows that we have created a file called draft.txt:\n$ ls\ndraft.txt\n\n\n\n\n\n\nCreating Files a Different Way\n\n\n\nWe have seen how to create text files using the nano editor. Now, try the following command:\n$ touch my_file.txt\n\nWhat did the touch command do? When you look at your current directory using the GUI file explorer, does the file show up?\nUse ls -l to inspect the files. How large is my_file.txt?\nWhen might you want to create a file this way?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThe touch command generates a new file called my_file.txt in your current directory. You can observe this newly generated file by typing ls at the command line prompt. my_file.txt can also be viewed in your GUI file explorer.\nWhen you inspect the file with ls -l, note that the size of my_file.txt is 0 bytes. In other words, it contains no data. If you open my_file.txt using your text editor it is blank.\nSome programs do not generate output files themselves, but instead require that empty files have already been generated. When the program is run, it searches for an existing file to populate with its output. The touch command allows you to efficiently generate a blank text file to be used by such programs.\n\nTo avoid confusion later on, we suggest removing the file you’ve just created before proceeding with the rest of the episode, otherwise future outputs may vary from those given in the lesson. To do this, use the following command:\n$ rm my_file.txt\n\n\n\n\n\n\n\n\n\nWhat’s In A Name?\n\n\n\nYou may have noticed that all of Nelle’s files are named ‘something dot something’, and in this part of the lesson, we always used the extension .txt. This is just a convention; we can call a file mythesis or almost anything else we want. However, most people use two-part names most of the time to help them (and their programs) tell different kinds of files apart. The second part of such a name is called the filename extension and indicates what type of data the file holds: .txt signals a plain text file, .pdf indicates a PDF document, .cfg is a configuration file full of parameters for some program or other, .png is a PNG image, and so on.\nThis is just a convention, albeit an important one. Files merely contain bytes; it’s up to us and our programs to interpret those bytes according to the rules for plain text files, PDF documents, configuration files, images, and so on.\nNaming a PNG image of a whale as whale.mp3 doesn’t somehow magically turn it into a recording of whale song, though it might cause the operating system to associate the file with a music player program. In this case, if someone double-clicked whale.mp3 in a file explorer program, the music player will automatically (and erroneously) attempt to open the whale.mp3 file."
  },
  {
    "objectID": "episodes/03-create.html#moving-files-and-directories",
    "href": "episodes/03-create.html#moving-files-and-directories",
    "title": "Working With Files and Directories",
    "section": "Moving files and directories",
    "text": "Moving files and directories\nReturning to the shell-lesson-data/exercise-data/writing directory,\n$ cd ~/Desktop/shell-lesson-data/exercise-data/writing\nIn our thesis directory we have a file draft.txt which isn’t a particularly informative name, so let’s change the file’s name using mv, which is short for ‘move’:\n$ mv thesis/draft.txt thesis/quotes.txt\nThe first argument tells mv what we’re ‘moving’, while the second is where it’s to go. In this case, we’re moving thesis/draft.txt to thesis/quotes.txt, which has the same effect as renaming the file. Sure enough, ls shows us that thesis now contains one file called quotes.txt:\n$ ls thesis\nquotes.txt\nOne must be careful when specifying the target file name, since mv will silently overwrite any existing file with the same name, which could lead to data loss. By default, mv will not ask for confirmation before overwriting files. However, an additional option, mv -i (or mv --interactive), will cause mv to request such confirmation.\nNote that mv also works on directories.\nLet’s move quotes.txt into the current working directory. We use mv once again, but this time we’ll use just the name of a directory as the second argument to tell mv that we want to keep the filename but put the file somewhere new. (This is why the command is called ‘move’.) In this case, the directory name we use is the special directory name . that we mentioned earlier.\n$ mv thesis/quotes.txt .\nThe effect is to move the file from the directory it was in to the current working directory. ls now shows us that thesis is empty:\n$ ls thesis\n$\nAlternatively, we can confirm the file quotes.txt is no longer present in the thesis directory by explicitly trying to list it:\n$ ls thesis/quotes.txt\nls: cannot access 'thesis/quotes.txt': No such file or directory\nls with a filename or directory as an argument only lists the requested file or directory. If the file given as the argument doesn’t exist, the shell returns an error as we saw above. We can use this to see that quotes.txt is now present in our current directory:\n$ ls quotes.txt\nquotes.txt\n\n\n\n\n\n\nMoving Files to a new folder\n\n\n\nAfter running the following commands, Jamie realizes that she put the files sucrose.dat and maltose.dat into the wrong folder. The files should have been placed in the raw folder.\n$ ls -F\n analyzed/ raw/\n$ ls -F analyzed\nfructose.dat glucose.dat maltose.dat sucrose.dat\n$ cd analyzed\nFill in the blanks to move these files to the raw/ folder (i.e. the one she forgot to put them in)\n$ mv sucrose.dat maltose.dat ____/____\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n$ mv sucrose.dat maltose.dat ../raw\nRecall that .. refers to the parent directory (i.e. one above the current directory) and that . refers to the current directory."
  },
  {
    "objectID": "episodes/03-create.html#copying-files-and-directories",
    "href": "episodes/03-create.html#copying-files-and-directories",
    "title": "Working With Files and Directories",
    "section": "Copying files and directories",
    "text": "Copying files and directories\nThe cp command works very much like mv, except it copies a file instead of moving it. We can check that it did the right thing using ls with two paths as arguments — like most Unix commands, ls can be given multiple paths at once:\n$ cp quotes.txt thesis/quotations.txt\n$ ls quotes.txt thesis/quotations.txt\nquotes.txt   thesis/quotations.txt\nWe can also copy a directory and all its contents by using the recursive option -r, e.g. to back up a directory:\n$ cp -r thesis thesis_backup\nWe can check the result by listing the contents of both the thesis and thesis_backup directory:\n$ ls thesis thesis_backup\nthesis:\nquotations.txt\n\nthesis_backup:\nquotations.txt\nIt is important to include the -r flag. If you want to copy a directory and you omit this option you will see a message that the directory has been omitted because -r not specified.\n$ cp thesis thesis_backup\ncp: -r not specified; omitting directory 'thesis'\n\n\n\n\n\n\nRenaming Files\n\n\n\nSuppose that you created a plain-text file in your current directory to contain a list of the statistical tests you will need to do to analyze your data, and named it statstics.txt\nAfter creating and saving this file you realize you misspelled the filename! You want to correct the mistake, which of the following commands could you use to do so?\n\ncp statstics.txt statistics.txt\nmv statstics.txt statistics.txt\nmv statstics.txt .\ncp statstics.txt .\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nNo. While this would create a file with the correct name, the incorrectly named file still exists in the directory and would need to be deleted.\nYes, this would work to rename the file.\nNo, the period(.) indicates where to move the file, but does not provide a new file name; identical file names cannot be created.\nNo, the period(.) indicates where to copy the file, but does not provide a new file name; identical file names cannot be created.\n\n\n\n\n\n\n\n\n\n\nMoving and Copying\n\n\n\nWhat is the output of the closing ls command in the sequence shown below?\n$ pwd\n/Users/jamie/data\n$ ls\nproteins.dat\n$ mkdir recombined\n$ mv proteins.dat recombined/\n$ cp recombined/proteins.dat ../proteins-saved.dat\n$ ls\n\nproteins-saved.dat recombined\nrecombined\nproteins.dat recombined\nproteins-saved.dat\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe start in the /Users/jamie/data directory, and create a new folder called recombined. The second line moves (mv) the file proteins.dat to the new folder (recombined). The third line makes a copy of the file we just moved. The tricky part here is where the file was copied to. Recall that .. means ‘go up a level’, so the copied file is now in /Users/jamie. Notice that .. is interpreted with respect to the current working directory, not with respect to the location of the file being copied. So, the only thing that will show using ls (in /Users/jamie/data) is the recombined folder.\n\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie\nYes\nNo, see explanation above. proteins.dat is located at /Users/jamie/data/recombined\nNo, see explanation above. proteins-saved.dat is located at /Users/jamie"
  },
  {
    "objectID": "episodes/03-create.html#removing-files-and-directories",
    "href": "episodes/03-create.html#removing-files-and-directories",
    "title": "Working With Files and Directories",
    "section": "Removing files and directories",
    "text": "Removing files and directories\nReturning to the shell-lesson-data/exercise-data/writing directory, let’s tidy up this directory by removing the quotes.txt file we created. The Unix command we’ll use for this is rm (short for ‘remove’):\n$ rm quotes.txt\nWe can confirm the file has gone using ls:\n$ ls quotes.txt\nls: cannot access 'quotes.txt': No such file or directory\n\n\n\n\n\n\nDeleting Is Forever\n\n\n\nThe Unix shell doesn’t have a trash bin that we can recover deleted files from (though most graphical interfaces to Unix do). Instead, when we delete files, they are unlinked from the file system so that their storage space on disk can be recycled. Tools for finding and recovering deleted files do exist, but there’s no guarantee they’ll work in any particular situation, since the computer may recycle the file’s disk space right away.\n\n\n\n\n\n\n\n\nUsing rm Safely\n\n\n\nWhat happens when we execute rm -i thesis_backup/quotations.txt? Why would we want this protection when using rm?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nrm: remove regular file 'thesis_backup/quotations.txt'? y\nThe -i option will prompt before (every) removal (use Y to confirm deletion or N to keep the file). The Unix shell doesn’t have a trash bin, so all the files removed will disappear forever. By using the -i option, we have the chance to check that we are deleting only the files that we want to remove.\n\n\n\nIf we try to remove the thesis directory using rm thesis, we get an error message:\n$ rm thesis\nrm: cannot remove 'thesis': Is a directory\nThis happens because rm by default only works on files, not directories.\nrm can remove a directory and all its contents if we use the recursive option -r, and it will do so without any confirmation prompts:\n$ rm -r thesis\nGiven that there is no way to retrieve files deleted using the shell, rm -r should be used with great caution (you might consider adding the interactive option rm -r -i)."
  },
  {
    "objectID": "episodes/03-create.html#operations-with-multiple-files-and-directories",
    "href": "episodes/03-create.html#operations-with-multiple-files-and-directories",
    "title": "Working With Files and Directories",
    "section": "Operations with multiple files and directories",
    "text": "Operations with multiple files and directories\nOftentimes one needs to copy or move several files at once. This can be done by providing a list of individual filenames, or specifying a naming pattern using wildcards. Wildcards are special characters that can be used to represent unknown characters or sets of characters when navigating the Unix file system.\n\n\n\n\n\n\nCopy with Multiple Filenames\n\n\n\nFor this exercise, you can test the commands in the shell-lesson-data/exercise-data directory.\nWe have seen how cp behaves when given two arguments, but cp behaves differently when given three or more arguments. Let’s try giving cp three arguments. In the example below, what does cp do when given several filenames and a directory name?\n$ mkdir backup\n$ cp creatures/minotaur.dat creatures/unicorn.dat backup/\nIn the example below, what does cp do when given three or more file names?\n$ cd creatures\n$ ls -F\nbasilisk.dat  minotaur.dat  unicorn.dat\n$ cp minotaur.dat unicorn.dat basilisk.dat\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWhen cp is given two arguments and the second is a destination directory cp copies the files to the destination directory.\nIf given three or more arguments, cp throws an error such as the one below, because it is expecting a destination directory name as the last argument.\ncp: target 'basilisk.dat' is not a directory\n\n\n\n\nUsing wildcards for accessing multiple files at once\n\n\n\n\n\n\nWildcards\n\n\n\n* is a wildcard, which represents zero or more other characters. Let’s consider the shell-lesson-data/exercise-data/alkanes directory: *.pdb represents ethane.pdb, propane.pdb, and every file that ends with ‘.pdb’. On the other hand, p*.pdb only represents pentane.pdb and propane.pdb, because the ‘p’ at the front can only represent filenames that begin with the letter ‘p’.\n? is also a wildcard, but it represents exactly one character. So ?ethane.pdb could represent methane.pdb whereas *ethane.pdb represents both ethane.pdb and methane.pdb.\nWildcards can be used in combination with each other. For example, ???ane.pdb indicates three characters followed by ane.pdb, giving cubane.pdb  ethane.pdb  octane.pdb.\nWhen the shell sees a wildcard, it expands the wildcard to create a list of matching filenames before running the preceding command. As an exception, if a wildcard expression does not match any file, Bash will pass the expression as an argument to the command as it is. For example, typing ls *.pdf in the alkanes directory (which contains only files with names ending with .pdb) results in an error message that there is no file called *.pdf. However, generally commands like wc and ls see the lists of file names matching these expressions, but not the wildcards themselves. It is the shell, not the other programs, that expands the wildcards.\n\n\n\n\n\n\n\n\nList filenames matching a pattern\n\n\n\nWhen run in the alkanes directory, which ls command(s) will produce this output?\nethane.pdb   methane.pdb\n\nls *t*ane.pdb\nls *t?ne.*\nls *t??ne.pdb\nls ethane.*\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe solution is 3.\n1. shows all files whose names contain zero or more characters (*) followed by the letter t, then zero or more characters (*) followed by ane.pdb. This gives ethane.pdb  methane.pdb  octane.pdb  pentane.pdb.\n2. shows all files whose names start with zero or more characters (*) followed by the letter t, then a single character (?), then ne. followed by zero or more characters (*). This will give us octane.pdb and pentane.pdb but doesn’t match anything which ends in thane.pdb.\n3. fixes the problems of option 2 by matching two characters (??) between t and ne. This is the solution.\n4. only shows files starting with ethane..\n\n\n\n\n\n\n\n\n\nMore on Wildcards\n\n\n\nSam has a directory containing calibration data, datasets, and descriptions of the datasets:\n.\n├── 2015-10-23-calibration.txt\n├── 2015-10-23-dataset1.txt\n├── 2015-10-23-dataset2.txt\n├── 2015-10-23-dataset_overview.txt\n├── 2015-10-26-calibration.txt\n├── 2015-10-26-dataset1.txt\n├── 2015-10-26-dataset2.txt\n├── 2015-10-26-dataset_overview.txt\n├── 2015-11-23-calibration.txt\n├── 2015-11-23-dataset1.txt\n├── 2015-11-23-dataset2.txt\n├── 2015-11-23-dataset_overview.txt\n├── backup\n│   ├── calibration\n│   └── datasets\n└── send_to_bob\n    ├── all_datasets_created_on_a_23rd\n    └── all_november_files\nBefore heading off to another field trip, she wants to back up her data and send some datasets to her colleague Bob. Sam uses the following commands to get the job done:\n$ cp *dataset* backup/datasets\n$ cp ____calibration____ backup/calibration\n$ cp 2015-____-____ send_to_bob/all_november_files/\n$ cp ____ send_to_bob/all_datasets_created_on_a_23rd/\nHelp Sam by filling in the blanks.\nThe resulting directory structure should look like this\n.\n├── 2015-10-23-calibration.txt\n├── 2015-10-23-dataset1.txt\n├── 2015-10-23-dataset2.txt\n├── 2015-10-23-dataset_overview.txt\n├── 2015-10-26-calibration.txt\n├── 2015-10-26-dataset1.txt\n├── 2015-10-26-dataset2.txt\n├── 2015-10-26-dataset_overview.txt\n├── 2015-11-23-calibration.txt\n├── 2015-11-23-dataset1.txt\n├── 2015-11-23-dataset2.txt\n├── 2015-11-23-dataset_overview.txt\n├── backup\n│   ├── calibration\n│   │   ├── 2015-10-23-calibration.txt\n│   │   ├── 2015-10-26-calibration.txt\n│   │   └── 2015-11-23-calibration.txt\n│   └── datasets\n│       ├── 2015-10-23-dataset1.txt\n│       ├── 2015-10-23-dataset2.txt\n│       ├── 2015-10-23-dataset_overview.txt\n│       ├── 2015-10-26-dataset1.txt\n│       ├── 2015-10-26-dataset2.txt\n│       ├── 2015-10-26-dataset_overview.txt\n│       ├── 2015-11-23-dataset1.txt\n│       ├── 2015-11-23-dataset2.txt\n│       └── 2015-11-23-dataset_overview.txt\n└── send_to_bob\n    ├── all_datasets_created_on_a_23rd\n    │   ├── 2015-10-23-dataset1.txt\n    │   ├── 2015-10-23-dataset2.txt\n    │   ├── 2015-10-23-dataset_overview.txt\n    │   ├── 2015-11-23-dataset1.txt\n    │   ├── 2015-11-23-dataset2.txt\n    │   └── 2015-11-23-dataset_overview.txt\n    └── all_november_files\n        ├── 2015-11-23-calibration.txt\n        ├── 2015-11-23-dataset1.txt\n        ├── 2015-11-23-dataset2.txt\n        └── 2015-11-23-dataset_overview.txt\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n$ cp *calibration.txt backup/calibration\n$ cp 2015-11-* send_to_bob/all_november_files/\n$ cp *-23-dataset* send_to_bob/all_datasets_created_on_a_23rd/\n\n\n\n\n\n\n\n\n\nOrganizing Directories and Files\n\n\n\nJamie is working on a project, and she sees that her files aren’t very well organized:\n$ ls -F\nanalyzed/  fructose.dat    raw/   sucrose.dat\nThe fructose.dat and sucrose.dat files contain output from her data analysis. What command(s) covered in this lesson does she need to run so that the commands below will produce the output shown?\n$ ls -F\nanalyzed/   raw/\n$ ls analyzed\nfructose.dat    sucrose.dat\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nmv *.dat analyzed\nJamie needs to move her files fructose.dat and sucrose.dat to the analyzed directory. The shell will expand *.dat to match all .dat files in the current directory. The mv command then moves the list of .dat files to the ‘analyzed’ directory.\n\n\n\n\n\n\n\n\n\nReproduce a folder structure\n\n\n\nYou’re starting a new experiment and would like to duplicate the directory structure from your previous experiment so you can add new data.\nAssume that the previous experiment is in a folder called 2016-05-18, which contains a data folder that in turn contains folders named raw and processed that contain data files. The goal is to copy the folder structure of the 2016-05-18 folder into a folder called 2016-05-20 so that your final directory structure looks like this:\n2016-05-20/\n└── data\n   ├── processed\n   └── raw\nWhich of the following set of commands would achieve this objective? What would the other commands do?\n$ mkdir 2016-05-20\n$ mkdir 2016-05-20/data\n$ mkdir 2016-05-20/data/processed\n$ mkdir 2016-05-20/data/raw\n$ mkdir 2016-05-20\n$ cd 2016-05-20\n$ mkdir data\n$ cd data\n$ mkdir raw processed\n$ mkdir 2016-05-20/data/raw\n$ mkdir 2016-05-20/data/processed\n$ mkdir -p 2016-05-20/data/raw\n$ mkdir -p 2016-05-20/data/processed\n$ mkdir 2016-05-20\n$ cd 2016-05-20\n$ mkdir data\n$ mkdir raw processed\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe first two sets of commands achieve this objective. The first set uses relative paths to create the top-level directory before the subdirectories.\nThe third set of commands will give an error because the default behavior of mkdir won’t create a subdirectory of a non-existent directory: the intermediate level folders must be created first.\nThe fourth set of commands achieve this objective. Remember, the -p option, followed by a path of one or more directories, will cause mkdir to create any intermediate subdirectories as required.\nThe final set of commands generates the ‘raw’ and ‘processed’ directories at the same level as the ‘data’ directory.\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\ncp [old] [new] copies a file.\nmkdir [path] creates a new directory.\nmv [old] [new] moves (renames) a file or directory.\nrm [path] removes (deletes) a file.\n* matches zero or more characters in a filename, so *.txt matches all files ending in .txt.\n? matches any single character in a filename, so ?.txt matches a.txt but not any.txt.\nUse of the Control key may be described in many ways, including Ctrl-X, Control-X, and ^X.\nThe shell does not have a trash bin: once something is deleted, it’s really gone.\nMost files’ names are something.extension. The extension isn’t required, and doesn’t guarantee anything, but is normally used to indicate the type of data in the file.\nDepending on the type of work you do, you may need a more powerful text editor than Nano.\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/05-pipefilter.html",
    "href": "episodes/05-pipefilter.html",
    "title": "Pipes and Filters",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 25\nExercises: 10\nQuestions:\n\nHow can I combine existing commands to produce a desired output?\nHow can I show only part of the output?\n\nObjectives:\n\nExplain the advantage of linking commands with pipes and filters.\nCombine sequences of commands to get new output\nRedirect a command’s output to a file.\nExplain what usually happens if a program or pipeline isn’t given any input to process.\nNow that we know a few basic commands, we can finally look at the shell’s most powerful feature: the ease with which it lets us combine existing programs in new ways. We’ll start with the directory shell-lesson-data/exercise-data/alkanes that contains six files describing some simple organic molecules. The .pdb extension indicates that these files are in Protein Data Bank format, a simple text format that specifies the type and position of each atom in the molecule.\nLet’s run an example command:\nwc is the ‘word count’ command: it counts the number of lines, words, and characters in files (returning the values in that order from left to right).\nIf we run the command wc *.pdb, the * in *.pdb matches zero or more characters, so the shell turns *.pdb into a list of all .pdb files in the current directory:\nNote that wc *.pdb also shows the total number of all lines in the last line of the output.\nIf we run wc -l instead of just wc, the output shows only the number of lines per file:\nThe -m and -w options can also be used with the wc command to show only the number of characters or the number of words, respectively."
  },
  {
    "objectID": "episodes/05-pipefilter.html#capturing-output-from-commands",
    "href": "episodes/05-pipefilter.html#capturing-output-from-commands",
    "title": "Pipes and Filters",
    "section": "Capturing output from commands",
    "text": "Capturing output from commands\nWhich of these files contains the fewest lines? It’s an easy question to answer when there are only six files, but what if there were 6000? Our first step toward a solution is to run the command:\n$ wc -l *.pdb &gt; lengths.txt\nThe greater than symbol, &gt;, tells the shell to redirect the command’s output to a file instead of printing it to the screen. This command prints no screen output, because everything that wc would have printed has gone into the file lengths.txt instead. If the file doesn’t exist prior to issuing the command, the shell will create the file. If the file exists already, it will be silently overwritten, which may lead to data loss. Thus, redirect commands require caution.\nls lengths.txt confirms that the file exists:\n$ ls lengths.txt\nlengths.txt\nWe can now send the content of lengths.txt to the screen using cat lengths.txt. The cat command gets its name from ‘concatenate’ i.e. join together, and it prints the contents of files one after another. There’s only one file in this case, so cat just shows us what it contains:\n$ cat lengths.txt\n  20  cubane.pdb\n  12  ethane.pdb\n   9  methane.pdb\n  30  octane.pdb\n  21  pentane.pdb\n  15  propane.pdb\n 107  total\n\n\n\n\n\n\nOutput Page by Page\n\n\n\nWe’ll continue to use cat in this lesson, for convenience and consistency, but it has the disadvantage that it always dumps the whole file onto your screen. More useful in practice is the command less (e.g. less lengths.txt). This displays a screenful of the file, and then stops. You can go forward one screenful by pressing the spacebar, or back one by pressing b. Press q to quit."
  },
  {
    "objectID": "episodes/05-pipefilter.html#filtering-output",
    "href": "episodes/05-pipefilter.html#filtering-output",
    "title": "Pipes and Filters",
    "section": "Filtering output",
    "text": "Filtering output\nNext we’ll use the sort command to sort the contents of the lengths.txt file. But first we’ll do an exercise to learn a little about the sort command:\n\n\n\n\n\n\nWhat Does sort -n Do?\n\n\n\nThe file shell-lesson-data/exercise-data/numbers.txt contains the following lines:\n10\n2\n19\n22\n6\nIf we run sort on this file, the output is:\n10\n19\n2\n22\n6\nIf we run sort -n on the same file, we get this instead:\n2\n6\n10\n19\n22\nExplain why -n has this effect.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe -n option specifies a numerical rather than an alphanumerical sort.\n\n\n\nWe will also use the -n option to specify that the sort is numerical instead of alphanumerical. This does not change the file; instead, it sends the sorted result to the screen:\n$ sort -n lengths.txt\n  9  methane.pdb\n 12  ethane.pdb\n 15  propane.pdb\n 20  cubane.pdb\n 21  pentane.pdb\n 30  octane.pdb\n107  total\nWe can put the sorted list of lines in another temporary file called sorted-lengths.txt by putting &gt; sorted-lengths.txt after the command, just as we used &gt; lengths.txt to put the output of wc into lengths.txt. Once we’ve done that, we can run another command called head to get the first few lines in sorted-lengths.txt:\n$ sort -n lengths.txt &gt; sorted-lengths.txt\n$ head -n 1 sorted-lengths.txt\n  9  methane.pdb\nUsing -n 1 with head tells it that we only want the first line of the file; -n 20 would get the first 20, and so on. Since sorted-lengths.txt contains the lengths of our files ordered from least to greatest, the output of head must be the file with the fewest lines.\n\n\n\n\n\n\nRedirecting to the same file\n\n\n\nIt’s a very bad idea to try redirecting the output of a command that operates on a file to the same file. For example:\n$ sort -n lengths.txt &gt; lengths.txt\nDoing something like this may give you incorrect results and/or delete the contents of lengths.txt.\n\n\n\n\n\n\n\n\nWhat Does &gt;&gt; Mean?\n\n\n\nWe have seen the use of &gt;, but there is a similar operator &gt;&gt; which works slightly differently. We’ll learn about the differences between these two operators by printing some strings. We can use the echo command to print strings e.g.\n$ echo The echo command prints text\nThe echo command prints text\nNow test the commands below to reveal the difference between the two operators:\n$ echo hello &gt; testfile01.txt\nand:\n$ echo hello &gt;&gt; testfile02.txt\nHint: Try executing each command twice in a row and then examining the output files.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIn the first example with &gt;, the string ‘hello’ is written to testfile01.txt, but the file gets overwritten each time we run the command.\nWe see from the second example that the &gt;&gt; operator also writes ‘hello’ to a file (in this case testfile02.txt), but appends the string to the file if it already exists (i.e. when we run it for the second time).\n\n\n\n\n\n\n\n\n\nAppending Data\n\n\n\nWe have already met the head command, which prints lines from the start of a file. tail is similar, but prints lines from the end of a file instead.\nConsider the file shell-lesson-data/exercise-data/animal-counts/animals.csv. After these commands, select the answer that corresponds to the file animals-subset.csv:\n$ head -n 3 animals.csv &gt; animals-subset.csv\n$ tail -n 2 animals.csv &gt;&gt; animals-subset.csv\n\nThe first three lines of animals.csv\nThe last two lines of animals.csv\nThe first three lines and the last two lines of animals.csv\nThe second and third lines of animals.csv\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 3 is correct. For option 1 to be correct we would only run the head command. For option 2 to be correct we would only run the tail command. For option 4 to be correct we would have to pipe the output of head into tail -n 2 by doing head -n 3 animals.csv | tail -n 2 &gt; animals-subset.csv"
  },
  {
    "objectID": "episodes/05-pipefilter.html#passing-output-to-another-command",
    "href": "episodes/05-pipefilter.html#passing-output-to-another-command",
    "title": "Pipes and Filters",
    "section": "Passing output to another command",
    "text": "Passing output to another command\nIn our example of finding the file with the fewest lines, we are using two intermediate files lengths.txt and sorted-lengths.txt to store output. This is a confusing way to work because even once you understand what wc, sort, and head do, those intermediate files make it hard to follow what’s going on. We can make it easier to understand by running sort and head together:\n$ sort -n lengths.txt | head -n 1\n  9  methane.pdb\nThe vertical bar, |, between the two commands is called a pipe. It tells the shell that we want to use the output of the command on the left as the input to the command on the right.\nThis has removed the need for the sorted-lengths.txt file."
  },
  {
    "objectID": "episodes/05-pipefilter.html#combining-multiple-commands",
    "href": "episodes/05-pipefilter.html#combining-multiple-commands",
    "title": "Pipes and Filters",
    "section": "Combining multiple commands",
    "text": "Combining multiple commands\nNothing prevents us from chaining pipes consecutively. We can for example send the output of wc directly to sort, and then send the resulting output to head. This removes the need for any intermediate files.\nWe’ll start by using a pipe to send the output of wc to sort:\n$ wc -l *.pdb | sort -n\n   9 methane.pdb\n  12 ethane.pdb\n  15 propane.pdb\n  20 cubane.pdb\n  21 pentane.pdb\n  30 octane.pdb\n 107 total\nWe can then send that output through another pipe, to head, so that the full pipeline becomes:\n$ wc -l *.pdb | sort -n | head -n 1\n   9  methane.pdb\nThis is exactly like a mathematician nesting functions like log(3x) and saying ‘the log of three times x’. In our case, the algorithm is ‘head of sort of line count of *.pdb’.\nThe redirection and pipes used in the last few commands are illustrated below:\n\n\n\n\n\n\n\nPiping Commands Together\n\n\n\nIn our current directory, we want to find the 3 files which have the least number of lines. Which command listed below would work?\n\nwc -l * &gt; sort -n &gt; head -n 3\nwc -l * | sort -n | head -n 1-3\nwc -l * | head -n 3 | sort -n\nwc -l * | sort -n | head -n 3\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4 is the solution. The pipe character | is used to connect the output from one command to the input of another. &gt; is used to redirect standard output to a file. Try it in the shell-lesson-data/exercise-data/alkanes directory!"
  },
  {
    "objectID": "episodes/05-pipefilter.html#tools-designed-to-work-together",
    "href": "episodes/05-pipefilter.html#tools-designed-to-work-together",
    "title": "Pipes and Filters",
    "section": "Tools designed to work together",
    "text": "Tools designed to work together\nThis idea of linking programs together is why Unix has been so successful. Instead of creating enormous programs that try to do many different things, Unix programmers focus on creating lots of simple tools that each do one job well, and that work well with each other. This programming model is called ‘pipes and filters’. We’ve already seen pipes; a filter is a program like wc or sort that transforms a stream of input into a stream of output. Almost all of the standard Unix tools can work this way. Unless told to do otherwise, they read from standard input, do something with what they’ve read, and write to standard output.\nThe key is that any program that reads lines of text from standard input and writes lines of text to standard output can be combined with every other program that behaves this way as well. You can and should write your programs this way so that you and other people can put those programs into pipes to multiply their power.\n\n\n\n\n\n\nPipe Reading Comprehension\n\n\n\nA file called animals.csv (in the shell-lesson-data/exercise-data/animal-counts folder) contains the following data:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nWhat text passes through each of the pipes and the final redirect in the pipeline below? Note, the sort -r command sorts in reverse order.\n$ cat animals.csv | head -n 5 | tail -n 3 | sort -r &gt; final.txt\nHint: build the pipeline up one command at a time to test your understanding\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe head command extracts the first 5 lines from animals.csv. Then, the last 3 lines are extracted from the previous 5 by using the tail command. With the sort -r command those 3 lines are sorted in reverse order. Finally, the output is redirected to a file: final.txt. The content of this file can be checked by executing cat final.txt. The file should contain the following lines:\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-05,raccoon,7\n\n\n\n\n\n\n\n\n\nPipe Construction\n\n\n\nFor the file animals.csv from the previous exercise, consider the following command:\n$ cut -d , -f 2 animals.csv\nThe cut command is used to select or ‘cut out’ certain sections of each line in the file for further processing while leaving the original file unchanged. By default, cut expects the lines to be separated into columns by a Tab character. A character used in this way is called a delimiter.\nIn the example above we use the -d option to specify the comma as our delimiter character instead of Tab. We have also used the -f option to specify that we want to extract the second field (column). This gives the following output:\ndeer\nrabbit\nraccoon\nrabbit\ndeer\nfox\nrabbit\nbear\nThe uniq command filters out adjacent matching lines in a file. How could you extend this pipeline (using uniq and another command) to find out what animals the file contains (without any duplicates in their names)?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n$ cut -d , -f 2 animals.csv | sort | uniq\n\n\n\n\n\n\n\n\n\nWhich Pipe?\n\n\n\nThe file animals.csv contains 8 lines of data formatted as follows:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n...\nThe uniq command has a -c option which gives a count of the number of times a line occurs in its input. Assuming your current directory is shell-lesson-data/exercise-data/animal-counts, what command would you use to produce a table that shows the total count of each type of animal in the file?\n\nsort animals.csv | uniq -c\nsort -t, -k2,2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c\ncut -d, -f 2 animals.csv | sort | uniq -c | wc -l\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 4 is the correct answer. If you have difficulty understanding why, try running the commands, or sub-sections of the pipelines (make sure you are in the shell-lesson-data/exercise-data/animal-counts directory)."
  },
  {
    "objectID": "episodes/05-pipefilter.html#nelles-pipeline-checking-files",
    "href": "episodes/05-pipefilter.html#nelles-pipeline-checking-files",
    "title": "Pipes and Filters",
    "section": "Nelle’s Pipeline: Checking Files",
    "text": "Nelle’s Pipeline: Checking Files\nNelle has run her samples through the assay machines and created 17 files in the north-pacific-gyre directory described earlier. As a quick check, starting from the shell-lesson-data directory, Nelle types:\n$ cd north-pacific-gyre\n$ wc -l *.txt\nThe output is 18 lines that look like this:\n300 NENE01729A.txt\n300 NENE01729B.txt\n300 NENE01736A.txt\n300 NENE01751A.txt\n300 NENE01751B.txt\n300 NENE01812A.txt\n... ...\nNow she types this:\n$ wc -l *.txt | sort -n | head -n 5\n 240 NENE02018B.txt\n 300 NENE01729A.txt\n 300 NENE01729B.txt\n 300 NENE01736A.txt\n 300 NENE01751A.txt\nWhoops: one of the files is 60 lines shorter than the others. When she goes back and checks it, she sees that she did that assay at 8:00 on a Monday morning — someone was probably in using the machine on the weekend, and she forgot to reset it. Before re-running that sample, she checks to see if any files have too much data:\n$ wc -l *.txt | sort -n | tail -n 5\n 300 NENE02040B.txt\n 300 NENE02040Z.txt\n 300 NENE02043A.txt\n 300 NENE02043B.txt\n5040 total\nThose numbers look good — but what’s that ‘Z’ doing there in the third-to-last line? All of her samples should be marked ‘A’ or ‘B’; by convention, her lab uses ‘Z’ to indicate samples with missing information. To find others like it, she does this:\n$ ls *Z.txt\nNENE01971Z.txt    NENE02040Z.txt\nSure enough, when she checks the log on her laptop, there’s no depth recorded for either of those samples. Since it’s too late to get the information any other way, she must exclude those two files from her analysis. She could delete them using rm, but there are actually some analyses she might do later where depth doesn’t matter, so instead, she’ll have to be careful later on to select files using the wildcard expressions NENE*A.txt NENE*B.txt.\n\n\n\n\n\n\nRemoving Unneeded Files\n\n\n\nSuppose you want to delete your processed data files, and only keep your raw files and processing script to save storage. The raw files end in .dat and the processed files end in .txt. Which of the following would remove all the processed data files, and only the processed data files?\n\nrm ?.txt\nrm *.txt\nrm * .txt\nrm *.*\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThis would remove .txt files with one-character names\nThis is the correct answer\nThe shell would expand * to match everything in the current directory, so the command would try to remove all matched files and an additional file called .txt\nThe shell expands *.* to match all filenames containing at least one ., including the processed files (.txt) and raw files (.dat)\n\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nwc counts lines, words, and characters in its inputs.\ncat displays the contents of its inputs.\nsort sorts its inputs.\nhead displays the first 10 lines of its input by default without additional arguments.\ntail displays the last 10 lines of its input by default without additional arguments.\ncommand &gt; [file] redirects a command’s output to a file (overwriting any existing content).\ncommand &gt;&gt; [file] appends a command’s output to a file.\n[first] | [second] is a pipeline: the output of the first command is used as the input to the second.\nThe best way to use the shell is to use pipes to combine simple single-purpose programs (filters).\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/04-permissions.html",
    "href": "episodes/04-permissions.html",
    "title": "File Permissions",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 10\nExercises: 5\nQuestions:\n\nHow do file and directory permissions work?\n\nObjectives:\n\nWhat are file and directory permissions?\nHow to view permissions?\nHow to change permissions?\nWhat are permission differences on Windows?\nUnix controls who can read, modify, and run files using permissions. We’ll discuss how Windows handles permissions at the end of the section: the concepts are similar, but the rules are different.\nLet’s start with Nelle. She has a unique user name, nnemo, and a user ID, 1404.\nUsers can belong to any number of groups, each with a name and numeric group ID. The list of who’s in what group is usually stored in the file /etc/group. (If you’re in front of a Unix machine right now, try running cat /etc/group to look at that file.)\nNow let’s look at files and directories. Every file and directory on a Unix computer belongs to one owner and one group. Along with each file’s content, the operating system stores the numeric IDs of the user and group that own it.\nThe user-and-group model means that for each file every user on the system falls into one of three categories: the owner of the file, someone in the file’s group, and everyone else.\nFor each of these three categories, the computer keeps track of whether people in that category can read the file, write to the file, or execute the file (i.e., run it if it is a program).\nFor example, if a file had the following set of permissions:\nit would mean that:\nLet’s look at this model in action. If we cd into the labs directory and run ls -F, it puts a * at the end of setup’s name. This is its way of telling us that setup is executable, i.e., that it’s (probably) something the computer can run."
  },
  {
    "objectID": "episodes/04-permissions.html#what-about-windows",
    "href": "episodes/04-permissions.html#what-about-windows",
    "title": "File Permissions",
    "section": "What about Windows?",
    "text": "What about Windows?\nThose are the basics of permissions on Unix. As we said at the outset, though, things work differently on Windows. There, permissions are defined by access control lists (ACLs). An ACL is a list of pairs, each of which combines a “who” with a “what”. For example, you could give the Mummy permission to append data to a file without giving him permission to read or delete it, and give Frankenstein permission to delete a file without being able to see what it contains.\nThis is more flexible that the Unix model, but it’s also more complex to administer and understand on small systems. (If you have a large computer system, nothing is easy to administer or understand.) Some modern variants of Unix support ACLs as well as the older read-write-execute permissions, but hardly anyone uses them.\n\n\n\n\n\n\nNote\n\n\n\nUnix uses owner/group/others with rwx triplets; Windows ACLs grant fine‑grained rights per user or group. Same ideas, different mechanisms.\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nIf ls -l myfile.php returns the following details:\n-rwxr-xr-- 1 caro zoo  2312  2014-10-25 18:30 myfile.php\nWhich of the following statements is true?\n\ncaro (the owner) can read, write, and execute myfile.php\ncaro (the owner) cannot write to myfile.php\nmembers of caro (a group) can read, write, and execute myfile.php\nmembers of zoo (a group) cannot execute myfile.php\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 1 is correct. The mode -rwxr-xr-- gives the owner rwx, the group r-x, and others r--. Therefore the owner can read, write, and execute; group members can read and execute (not write); others can only read.\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nCorrect permissions are critical for the security of a system.\nFile permissions describe who and what can read, write, modify, and access a file.\nUse ls -l to view the permissions for a specific file.\nUse chmod to change permissions on a file or directory.\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/08-find.html",
    "href": "episodes/08-find.html",
    "title": "Finding Things",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 25\nExercises: 20\nQuestions:\n\nHow can I find files?\nHow can I find things in files?\n\nObjectives:\n\nUse grep to select lines from text files that match simple patterns.\nUse find to find files and directories whose names match simple patterns.\nUse the output of one command as the command-line argument(s) to another command.\nExplain what is meant by ‘text’ and ‘binary’ files, and why many common tools don’t handle the latter well.\n\n\n\n\nIn the same way that many of us now use ‘Google’ as a verb meaning ‘to find’, Unix programmers often use the word ‘grep’. ‘grep’ is a contraction of ‘global/regular expression/print’, a common sequence of operations in early Unix text editors. It is also the name of a very useful command-line program.\ngrep finds and prints lines in files that match a pattern. For our examples, we will use a file that contains three haiku taken from a 1998 competition in Salon magazine (Credit to authors Bill Torcaso, Howard Korder, and Margaret Segall, respectively. See Haiku Error Messages archived Page 1 and Page 2 .). For this set of examples, we’re going to be working in the writing subdirectory:\n$ cd\n$ cd Desktop/shell-lesson-data/exercise-data/writing\n$ cat haiku.txt\nThe Tao that is seen\nIs not the true Tao, until\nYou bring fresh toner.\n\nWith searching comes loss\nand the presence of absence:\n\"My Thesis\" not found.\n\nYesterday it worked\nToday it is not working\nSoftware is like that.\nLet’s find lines that contain the word ‘not’:\n$ grep not haiku.txt\nIs not the true Tao, until\n\"My Thesis\" not found\nToday it is not working\nHere, not is the pattern we’re searching for. The grep command searches through the file, looking for matches to the pattern specified. To use it type grep, then the pattern we’re searching for and finally the name of the file (or files) we’re searching in.\nThe output is the three lines in the file that contain the letters ‘not’.\nBy default, grep searches for a pattern in a case-sensitive way. In addition, the search pattern we have selected does not have to form a complete word, as we will see in the next example.\nLet’s search for the pattern: ‘The’.\n$ grep The haiku.txt\nThe Tao that is seen\n\"My Thesis\" not found.\nThis time, two lines that include the letters ‘The’ are outputted, one of which contained our search pattern within a larger word, ‘Thesis’.\nTo restrict matches to lines containing the word ‘The’ on its own, we can give grep the -w option. This will limit matches to word boundaries.\nLater in this lesson, we will also see how we can change the search behavior of grep with respect to its case sensitivity.\n$ grep -w The haiku.txt\nThe Tao that is seen\nNote that a ‘word boundary’ includes the start and end of a line, so not just letters surrounded by spaces. Sometimes we don’t want to search for a single word, but a phrase. We can also do this with grep by putting the phrase in quotes.\n$ grep -w \"is not\" haiku.txt\nToday it is not working\nWe’ve now seen that you don’t have to have quotes around single words, but it is useful to use quotes when searching for multiple words. It also helps to make it easier to distinguish between the search term or phrase and the file being searched. We will use quotes in the remaining examples.\nAnother useful option is -n, which numbers the lines that match:\n$ grep -n \"it\" haiku.txt\n5:With searching comes loss\n9:Yesterday it worked\n10:Today it is not working\nHere, we can see that lines 5, 9, and 10 contain the letters ‘it’.\nWe can combine options (i.e. flags) as we do with other Unix commands. For example, let’s find the lines that contain the word ‘the’. We can combine the option -w to find the lines that contain the word ‘the’ and -n to number the lines that match:\n$ grep -n -w \"the\" haiku.txt\n2:Is not the true Tao, until\n6:and the presence of absence:\nNow we want to use the option -i to make our search case-insensitive:\n$ grep -n -w -i \"the\" haiku.txt\n1:The Tao that is seen\n2:Is not the true Tao, until\n6:and the presence of absence:\nNow, we want to use the option -v to invert our search, i.e., we want to output the lines that do not contain the word ‘the’.\n$ grep -n -w -v \"the\" haiku.txt\n1:The Tao that is seen\n3:You bring fresh toner.\n4:\n5:With searching comes loss\n7:\"My Thesis\" not found.\n8:\n9:Yesterday it worked\n10:Today it is not working\n11:Software is like that.\nIf we use the -r (recursive) option, grep can search for a pattern recursively through a set of files in subdirectories.\nLet’s search recursively for Yesterday in the shell-lesson-data/exercise-data/writing directory:\n$ grep -r Yesterday .\n./LittleWomen.txt:\"Yesterday, when Aunt was asleep and I was trying to be as still as a\n./LittleWomen.txt:Yesterday at dinner, when an Austrian officer stared at us and then\n./LittleWomen.txt:Yesterday was a quiet day spent in teaching, sewing, and writing in my\n./haiku.txt:Yesterday it worked\ngrep has lots of other options. To find out what they are, we can type:\n$ grep --help\nUsage: grep [OPTION]... PATTERN [FILE]...\nSearch for PATTERN in each FILE or standard input.\nPATTERN is, by default, a basic regular expression (BRE).\nExample: grep -i 'hello world' menu.h main.c\n\nRegexp selection and interpretation:\n  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)\n  -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings\n  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)\n  -P, --perl-regexp         PATTERN is a Perl regular expression\n  -e, --regexp=PATTERN      use PATTERN for matching\n  -f, --file=FILE           obtain PATTERN from FILE\n  -i, --ignore-case         ignore case distinctions\n  -w, --word-regexp         force PATTERN to match only whole words\n  -x, --line-regexp         force PATTERN to match only whole lines\n  -z, --null-data           a data line ends in 0 byte, not newline\n\nMiscellaneous:\n...        ...        ...\n\n\n\n\n\n\nUsing grep\n\n\n\nWhich command would result in the following output:\nand the presence of absence:\n\ngrep \"of\" haiku.txt\ngrep -E \"of\" haiku.txt\ngrep -w \"of\" haiku.txt\ngrep -i \"of\" haiku.txt\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe correct answer is 3, because the -w option looks only for whole-word matches. The other options will also match ‘of’ when part of another word.\n\n\n\n\n\n\n\n\n\nWildcards\n\n\n\ngrep‘s real power doesn’t come from its options, though; it comes from the fact that patterns can include wildcards. (The technical name for these is regular expressions, which is what the ’re’ in ‘grep’ stands for.) Regular expressions are both complex and powerful; if you want to do complex searches, please look at the lesson on our website. As a taster, we can find lines that have an ‘o’ in the second position like this:\n$ grep -E \"^.o\" haiku.txt\nYou bring fresh toner.\nToday it is not working\nSoftware is like that.\nWe use the -E option and put the pattern in quotes to prevent the shell from trying to interpret it. (If the pattern contained a *, for example, the shell would try to expand it before running grep.) The ^ in the pattern anchors the match to the start of the line. The . matches a single character (just like ? in the shell), while the o matches an actual ‘o’.\n\n\n\nFinding by Permissions\nfind can filter by file permissions using -perm. This is handy for locating executables or overly open files.\nFind regular files the owner can execute:\n$ find . -type f -perm -u=x\nFind files writable by the group or readable by others:\n$ find . -type f -perm -g=w      # group has write\n$ find . -type f -perm -o=r      # others have read\nThe leading - before each mode (e.g., -u=x) means “match if these bits are set”, not exactly equal to the mode.\n\n\n\n\n\n\nTracking a Species\n\n\n\nLeah has several hundred data files saved in one directory, each of which is formatted like this:\n2012-11-05,deer,5\n2012-11-05,rabbit,22\n2012-11-05,raccoon,7\n2012-11-06,rabbit,19\n2012-11-06,deer,2\n2012-11-06,fox,4\n2012-11-07,rabbit,16\n2012-11-07,bear,1\nShe wants to write a shell script that takes a species as the first command-line argument and a directory as the second argument. The script should return one file called &lt;species&gt;.txt containing a list of dates and the number of that species seen on each date. For example using the data shown above, rabbit.txt would contain:\n2012-11-05,22\n2012-11-06,19\n2012-11-07,16\nBelow, each line contains an individual command, or pipe. Arrange their sequence in one command in order to achieve Leah’s goal:\ncut -d : -f 2\n&gt;\n|\ngrep -w $1 -r $2\n|\n$1.txt\ncut -d , -f 1,3\nHint: use man grep to look for how to grep text recursively in a directory and man cut to select more than one field in a line.\nAn example of such a file is provided in shell-lesson-data/exercise-data/animal-counts/animals.csv\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\ngrep -w $1 -r $2 | cut -d : -f 2 | cut -d , -f 1,3 &gt; $1.txt\nActually, you can swap the order of the two cut commands and it still works. At the command line, try changing the order of the cut commands, and have a look at the output from each step to see why this is the case.\nYou would call the script above like this:\n$ bash count-species.sh bear .\n\n\n\n\n\n\n\n\n\nLittle Women\n\n\n\nYou and your friend, having just finished reading Little Women by Louisa May Alcott, are in an argument. Of the four sisters in the book, Jo, Meg, Beth, and Amy, your friend thinks that Jo was the most mentioned. You, however, are certain it was Amy. Luckily, you have a file LittleWomen.txt containing the full text of the novel (shell-lesson-data/exercise-data/writing/LittleWomen.txt). Using a for loop, how would you tabulate the number of times each of the four sisters is mentioned?\nHint: one solution might employ the commands grep and wc and a |, while another might utilize grep options. There is often more than one way to solve a programming task, so a particular solution is usually chosen based on a combination of yielding the correct result, elegance, readability, and speed.\n\n\n\n\n\n\n\n\nSolutions\n\n\n\n\n\nfor sis in Jo Meg Beth Amy\ndo\n    echo $sis:\n    grep -ow $sis LittleWomen.txt | wc -l\ndone\nAlternative, slightly inferior solution:\nfor sis in Jo Meg Beth Amy\ndo\n    echo $sis:\n    grep -ocw $sis LittleWomen.txt\ndone\nThis solution is inferior because grep -c only reports the number of lines matched. The total number of matches reported by this method will be lower if there is more than one match per line.\nPerceptive observers may have noticed that character names sometimes appear in all-uppercase in chapter titles (e.g. ‘MEG GOES TO VANITY FAIR’). If you wanted to count these as well, you could add the -i option for case-insensitivity (though in this case, it doesn’t affect the answer to which sister is mentioned most frequently).\n\n\n\nWhile grep finds lines in files, the find command finds files themselves. Again, it has a lot of options; to show how the simplest ones work, we’ll use the shell-lesson-data/exercise-data directory tree shown below.\n.\n├── animal-counts/\n│   └── animals.csv\n├── creatures/\n│   ├── basilisk.dat\n│   ├── minotaur.dat\n│   └── unicorn.dat\n├── numbers.txt\n├── alkanes/\n│   ├── cubane.pdb\n│   ├── ethane.pdb\n│   ├── methane.pdb\n│   ├── octane.pdb\n│   ├── pentane.pdb\n│   └── propane.pdb\n└── writing/\n    ├── haiku.txt\n    └── LittleWomen.txt\nThe exercise-data directory contains one file, numbers.txt and four directories: animal-counts, creatures, alkanes and writing containing various files.\nFor our first command, let’s run find . (remember to run this command from the shell-lesson-data/exercise-data folder).\n$ find .\n.\n./writing\n./writing/LittleWomen.txt\n./writing/haiku.txt\n./creatures\n./creatures/basilisk.dat\n./creatures/unicorn.dat\n./creatures/minotaur.dat\n./animal-counts\n./animal-counts/animals.csv\n./numbers.txt\n./alkanes\n./alkanes/ethane.pdb\n./alkanes/propane.pdb\n./alkanes/octane.pdb\n./alkanes/pentane.pdb\n./alkanes/methane.pdb\n./alkanes/cubane.pdb\nAs always, the . on its own means the current working directory, which is where we want our search to start. find’s output is the names of every file and directory under the current working directory. This can seem useless at first but find has many options to filter the output and in this lesson we will discover some of them.\nThe first option in our list is -type d that means ‘things that are directories’. Sure enough, find’s output is the names of the five directories (including .):\n$ find . -type d\n.\n./writing\n./creatures\n./animal-counts\n./alkanes\nNotice that the objects find finds are not listed in any particular order. If we change -type d to -type f, we get a listing of all the files instead:\n$ find . -type f\n./writing/LittleWomen.txt\n./writing/haiku.txt\n./creatures/basilisk.dat\n./creatures/unicorn.dat\n./creatures/minotaur.dat\n./animal-counts/animals.csv\n./numbers.txt\n./alkanes/ethane.pdb\n./alkanes/propane.pdb\n./alkanes/octane.pdb\n./alkanes/pentane.pdb\n./alkanes/methane.pdb\n./alkanes/cubane.pdb\nNow let’s try matching by name:\n$ find . -name *.txt\n./numbers.txt\nWe expected it to find all the text files, but it only prints out ./numbers.txt. The problem is that the shell expands wildcard characters like * before commands run. Since *.txt in the current directory expands to ./numbers.txt, the command we actually ran was:\n$ find . -name numbers.txt\nfind did what we asked; we just asked for the wrong thing.\nTo get what we want, let’s do what we did with grep: put *.txt in quotes to prevent the shell from expanding the * wildcard. This way, find actually gets the pattern *.txt, not the expanded filename numbers.txt:\n$ find . -name \"*.txt\"\n./writing/LittleWomen.txt\n./writing/haiku.txt\n./numbers.txt\n\n\n\n\n\n\nListing vs. Finding\n\n\n\nls and find can be made to do similar things given the right options, but under normal circumstances, ls lists everything it can, while find searches for things with certain properties and shows them.\n\n\nAs we said earlier, the command line’s power lies in combining tools. We’ve seen how to do that with pipes; let’s look at another technique. As we just saw, find . -name \"*.txt\" gives us a list of all text files in or below the current directory. How can we combine that with wc -l to count the lines in all those files?\nThe simplest way is to put the find command inside $():\n$ wc -l $(find . -name \"*.txt\")\n  21022 ./writing/LittleWomen.txt\n     11 ./writing/haiku.txt\n      5 ./numbers.txt\n  21038 total\nWhen the shell executes this command, the first thing it does is run whatever is inside the $(). It then replaces the $() expression with that command’s output. Since the output of find is the three filenames ./writing/LittleWomen.txt, ./writing/haiku.txt, and ./numbers.txt, the shell constructs the command:\n$ wc -l ./writing/LittleWomen.txt ./writing/haiku.txt ./numbers.txt\nwhich is what we wanted. This expansion is exactly what the shell does when it expands wildcards like * and ?, but lets us use any command we want as our own ‘wildcard’.\nIt’s very common to use find and grep together. The first finds files that match a pattern; the second looks for lines inside those files that match another pattern. Here, for example, we can find txt files that contain the word “searching” by looking for the string ‘searching’ in all the .txt files in the current directory:\n$ grep \"searching\" $(find . -name \"*.txt\")\n./writing/LittleWomen.txt:sitting on the top step, affected to be searching for her book, but was\n./writing/haiku.txt:With searching comes loss\n\n\n\n\n\n\nMatching and Subtracting\n\n\n\nThe -v option to grep inverts pattern matching, so that only lines which do not match the pattern are printed. Given that, which of the following commands will find all .dat files in creatures except unicorn.dat? Once you have thought about your answer, you can test the commands in the shell-lesson-data/exercise-data directory.\n\nfind creatures -name \"*.dat\" | grep -v unicorn\nfind creatures -name *.dat | grep -v unicorn\ngrep -v \"unicorn\" $(find creatures -name \"*.dat\")\nNone of the above.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nOption 1 is correct. Putting the match expression in quotes prevents the shell expanding it, so it gets passed to the find command.\nOption 2 also works in this instance because the shell tries to expand *.dat but there are no *.dat files in the current directory, so the wildcard expression gets passed to find. We first encountered this in episode 3.\nOption 3 is incorrect because it searches the contents of the files for lines which do not match ‘unicorn’, rather than searching the file names.\n\n\n\n\n\n\n\n\n\nBinary Files\n\n\n\nWe have focused exclusively on finding patterns in text files. What if your data is stored as images, in databases, or in some other format?\nA handful of tools extend grep to handle a few non text formats. But a more generalizable approach is to convert the data to text, or extract the text-like elements from the data. On the one hand, it makes simple things easy to do. On the other hand, complex things are usually impossible. For example, it’s easy enough to write a program that will extract X and Y dimensions from image files for grep to play with, but how would you write something to find values in a spreadsheet whose cells contained formulas?\nA last option is to recognize that the shell and text processing have their limits, and to use another programming language. When the time comes to do this, don’t be too hard on the shell. Many modern programming languages have borrowed a lot of ideas from it, and imitation is also the sincerest form of praise.\n\n\nThe Unix shell is older than most of the people who use it. It has survived so long because it is one of the most productive programming environments ever created — maybe even the most productive. Its syntax may be cryptic, but people who have mastered it can experiment with different commands interactively, then use what they have learned to automate their work. Graphical user interfaces may be easier to use at first, but once learned, the productivity in the shell is unbeatable. And as Alfred North Whitehead wrote in 1911, ‘Civilization advances by extending the number of important operations which we can perform without thinking about them.’\n\n\n\n\n\n\nfind Pipeline Reading Comprehension\n\n\n\nWrite a short explanatory comment for the following shell script:\nwc -l $(find . -name \"*.dat\") | sort -n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nFind all files with a .dat extension recursively from the current directory\nCount the number of lines each of these files contains\nSort the output from step 2. numerically\n\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nfind finds files with specific properties that match patterns.\ngrep selects lines in files that match patterns.\n--help is an option supported by many bash commands, and programs that can be run from within Bash, to display more information on how to use these commands or programs.\nman [command] displays the manual page for a given command.\n$([command]) inserts a command’s output in place.\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/01-intro.html",
    "href": "episodes/01-intro.html",
    "title": "Introducing the Shell",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 5\nExercises: 0\nQuestions:\n\nWhat is a command shell and why would I use one?\n\nObjectives:\n\nExplain how the shell relates to the keyboard, the screen, the operating system, and users’ programs.\nExplain when and why command-line interfaces should be used instead of graphical interfaces."
  },
  {
    "objectID": "episodes/01-intro.html#nelles-pipeline-a-typical-problem",
    "href": "episodes/01-intro.html#nelles-pipeline-a-typical-problem",
    "title": "Introducing the Shell",
    "section": "Nelle’s Pipeline: A Typical Problem",
    "text": "Nelle’s Pipeline: A Typical Problem\nNelle Nemo, a marine biologist, has just returned from a six-month survey of the North Pacific Gyre, where she has been sampling gelatinous marine life in the Great Pacific Garbage Patch. She has 1520 samples that she’s run through an assay machine to measure the relative abundance of 300 proteins. She needs to run these 1520 files through an imaginary program called goostats.sh. In addition to this huge task, she has to write up results by the end of the month, so her paper can appear in a special issue of Aquatic Goo Letters.\nIf Nelle chooses to run goostats.sh by hand using a GUI, she’ll have to select and open a file 1520 times. If goostats.sh takes 30 seconds to run each file, the whole process will take more than 12 hours of Nelle’s attention. With the shell, Nelle can instead assign her computer this mundane task while she focuses her attention on writing her paper.\nThe next few lessons will explore the ways Nelle can achieve this. More specifically, the lessons explain how she can use a command shell to run the goostats.sh program, using loops to automate the repetitive steps of entering file names, so that her computer can work while she writes her paper.\nAs a bonus, once she has put a processing pipeline together, she will be able to use it again whenever she collects more data.\nIn order to achieve her task, Nelle needs to know how to:\n\nnavigate to a file/directory\ncreate a file/directory\ncheck the length of a file\nchain commands together\nretrieve a set of files\niterate over files\nrun a shell script containing her pipeline\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nA shell is a program whose primary purpose is to read commands and run other programs.\nThis lesson uses Bash, the default shell in many implementations of Unix.\nPrograms can be run in Bash by entering commands at the command-line prompt.\nThe shell’s main advantages are its high action-to-keystroke ratio, its support for automating repetitive tasks, and its capacity to access networked machines.\nA significant challenge when using the shell can be knowing what commands need to be run and how to run them.\n\n\n\n\n\n\n \n\n\nNext →"
  },
  {
    "objectID": "episodes/06-loop.html",
    "href": "episodes/06-loop.html",
    "title": "Loops",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 40\nExercises: 10\nQuestions:\n\nHow can I perform the same actions on many different files?\n\nObjectives:\n\nWrite a loop that applies one or more commands separately to each file in a set of files.\nTrace the values taken on by a loop variable during execution of the loop.\nExplain the difference between a variable’s name and its value.\nExplain why spaces and some punctuation characters shouldn’t be used in file names.\nDemonstrate how to see what commands have recently been executed.\nRe-run recently executed commands without retyping them.\nLoops are a programming construct which allow us to repeat a command or set of commands for each item in a list. As such they are key to productivity improvements through automation. Similar to wildcards and tab completion, using loops also reduces the amount of typing required (and hence reduces the number of typing mistakes).\nSuppose we have several hundred genome data files named basilisk.dat, minotaur.dat, and unicorn.dat. For this example, we’ll use the exercise-data/creatures directory which only has three example files, but the principles can be applied to many many more files at once.\nThe structure of these files is the same: the common name, classification, and updated date are presented on the first three lines, with DNA sequences on the following lines. Let’s look at the files:\nWe would like to print out the classification for each species, which is given on the second line of each file. For each file, we would need to execute the command head -n 2 and pipe this to tail -n 1. We’ll use a loop to solve this problem, but first let’s look at the general form of a loop, using the pseudo-code below:\nand we can apply this to our example like this:\nWhen the shell sees the keyword for, it knows to repeat a command (or group of commands) once for each item in a list. Each time the loop runs (called an iteration), an item in the list is assigned in sequence to the variable, and the commands inside the loop are executed, before moving on to the next item in the list. Inside the loop, we call for the variable’s value by putting $ in front of it. The $ tells the shell interpreter to treat the variable as a variable name and substitute its value in its place, rather than treat it as text or an external command.\nIn this example, the list is three filenames: basilisk.dat, minotaur.dat, and unicorn.dat. Each time the loop iterates, we first use echo to print the value that the variable $filename currently holds. This is not necessary for the result, but beneficial for us here to have an easier time to follow along. Next, we will run the head command on the file currently referred to by $filename. The first time through the loop, $filename is basilisk.dat. The interpreter runs the command head on basilisk.dat and pipes the first two lines to the tail command, which then prints the second line of basilisk.dat. For the second iteration, $filename becomes minotaur.dat. This time, the shell runs head on minotaur.dat and pipes the first two lines to the tail command, which then prints the second line of minotaur.dat. For the third iteration, $filename becomes unicorn.dat, so the shell runs the head command on that file, and tail on the output of that. Since the list was only three items, the shell exits the for loop.\nWhen using variables it is also possible to put the names into curly braces to clearly delimit the variable name: $filename is equivalent to ${filename}, but is different from ${file}name. You may find this notation in other people’s programs.\nWe have called the variable in this loop filename in order to make its purpose clearer to human readers. The shell itself doesn’t care what the variable is called; if we wrote this loop as:\nor:\nit would work exactly the same way. Don’t do this. Programs are only useful if people can understand them, so meaningless names (like x) or misleading names (like temperature) increase the odds that the program won’t do what its readers think it does.\nIn the above examples, the variables (thing, filename, x and temperature) could have been given any other name, as long as it is meaningful to both the person writing the code and the person reading it.\nNote also that loops can be used for other things than filenames, like a list of numbers or a subset of data.\nLet’s continue with our example in the shell-lesson-data/exercise-data/creatures directory. Here’s another example:\nThe shell starts by expanding *.dat to create the list of files it will process. The loop body then executes two commands for each of those files. In the first command, $filename is expanded to the name of the file, so echo $filename prints the name of the file. Then, the head and tail combination selects lines 81-100 from whatever file is being processed (assuming the file has at least 100 lines).\nWe would like to modify each of the files in shell-lesson-data/exercise-data/creatures, but also save a version of the original files. We want to copy the original files to new files named original-basilisk.dat and original-unicorn.dat, for example. We can’t use:\nbecause that would expand to:\nThis wouldn’t back up our files, instead we get an error:\nThis problem arises when cp receives more than two inputs. When this happens, it expects the last input to be a directory where it can copy all the files it was passed. Since there is no directory named original-*.dat in the creatures directory, we get an error.\nInstead, we can use a loop:\nThis loop runs the cp command once for each filename. The first time, when $filename expands to basilisk.dat, the shell executes:\nThe second time, the command is:\nThe third and last time, the command is:\nSince the cp command does not normally produce any output, it’s hard to check that the loop is working correctly. However, we learned earlier how to print strings using echo, and we can modify the loop to use echo to print our commands without actually executing them. As such we can check what commands would be run in the unmodified loop.\nThe following diagram shows what happens when the modified loop is executed and demonstrates how the judicious use of echo is a good debugging technique."
  },
  {
    "objectID": "episodes/06-loop.html#nelles-pipeline-processing-files",
    "href": "episodes/06-loop.html#nelles-pipeline-processing-files",
    "title": "Loops",
    "section": "Nelle’s Pipeline: Processing Files",
    "text": "Nelle’s Pipeline: Processing Files\nNelle is now ready to process her data files using goostats.sh — a shell script written by her supervisor. This calculates some statistics from a protein sample file and takes two arguments:\n\nan input file (containing the raw data)\nan output file (to store the calculated statistics)\n\nSince she’s still learning how to use the shell, she decides to build up the required commands in stages. Her first step is to make sure that she can select the right input files — remember, these are ones whose names end in ‘A’ or ‘B’, rather than ‘Z’. Moving to the north-pacific-gyre directory, Nelle types:\n$ cd\n$ cd Desktop/shell-lesson-data/north-pacific-gyre\n$ for datafile in NENE*A.txt NENE*B.txt\n&gt; do\n&gt;     echo $datafile\n&gt; done\nNENE01729A.txt\nNENE01736A.txt\nNENE01751A.txt\n\n...\nNENE02040B.txt\nNENE02043B.txt\nHer next step is to decide what to call the files that the goostats.sh analysis program will create. Prefixing each input file’s name with ‘stats’ seems simple, so she modifies her loop to do that:\n$ for datafile in NENE*A.txt NENE*B.txt\n&gt; do\n&gt;     echo $datafile stats-$datafile\n&gt; done\nNENE01729A.txt stats-NENE01729A.txt\nNENE01736A.txt stats-NENE01729A.txt\nNENE01751A.txt stats-NENE01729A.txt\n...\nNENE02040B.txt stats-NENE02040B.txt\nNENE02043B.txt stats-NENE02043B.txt\nShe hasn’t actually run goostats.sh yet, but now she’s sure she can select the right files and generate the right output filenames.\nTyping in commands over and over again is becoming tedious, though, and Nelle is worried about making mistakes, so instead of re-entering her loop, she presses ↑. In response, the shell redisplays the whole loop on one line (using semi-colons to separate the pieces):\n$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\nUsing the ←, Nelle navigates to the echo command and changes it to bash goostats.sh:\n$ for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\nWhen she presses Enter, the shell runs the modified command. However, nothing appears to happen — there is no output. After a moment, Nelle realizes that since her script doesn’t print anything to the screen any longer, she has no idea whether it is running, much less how quickly. She kills the running command by typing Ctrl+C, uses ↑ to repeat the command, and edits it to read:\n$ for datafile in NENE*A.txt NENE*B.txt; do echo $datafile;\nbash goostats.sh $datafile stats-$datafile; done\n\n\n\n\n\n\nBeginning and End\n\n\n\nWe can move to the beginning of a line in the shell by typing Ctrl+A and to the end using Ctrl+E.\n\n\nWhen she runs her program now, it produces one line of output every five seconds or so:\nNENE01729A.txt\nNENE01736A.txt\nNENE01751A.txt\n...\n1518 times 5 seconds, divided by 60, tells her that her script will take about two hours to run. As a final check, she opens another terminal window, goes into north-pacific-gyre, and uses cat stats-NENE01729B.txt to examine one of the output files. It looks good, so she decides to get some coffee and catch up on her reading.\n\n\n\n\n\n\nThose Who Know History Can Choose to Repeat It\n\n\n\nAnother way to repeat previous work is to use the history command to get a list of the last few hundred commands that have been executed, and then to use !123 (where ‘123’ is replaced by the command number) to repeat one of those commands. For example, if Nelle types this:\n$ history | tail -n 5\n456  for datafile in NENE*A.txt NENE*B.txt; do   echo $datafile stats-$datafile; done\n457  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\n458  for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\n459  for datafile in NENE*A.txt NENE*B.txt; do echo $datafile; bash goostats.sh $datafile\nstats-$datafile; done\n460  history | tail -n 5\nthen she can re-run goostats.sh on the files simply by typing !459.\n\n\n\n\n\n\n\n\nOther History Commands\n\n\n\nThere are a number of other shortcut commands for getting at the history.\n\nCtrl+R enters a history search mode ‘reverse-i-search’ and finds the most recent command in your history that matches the text you enter next. Press Ctrl+R one or more additional times to search for earlier matches. You can then use the left and right arrow keys to choose that line and edit it then hit Return to run the command.\n!! retrieves the immediately preceding command (you may or may not find this more convenient than using ↑)\n!$ retrieves the last word of the last command. That’s useful more often than you might expect: after bash goostats.sh NENE01729B.txt stats-NENE01729B.txt, you can type less !$ to look at the file stats-NENE01729B.txt, which is quicker than doing ↑ and editing the command-line.\n\n\n\n\n\n\n\n\n\nDoing a Dry Run\n\n\n\nA loop is a way to do many things at once — or to make many mistakes at once if it does the wrong thing. One way to check what a loop would do is to echo the commands it would run instead of actually running them.\nSuppose we want to preview the commands the following loop will execute without actually running those commands:\n$ for datafile in *.pdb\n&gt; do\n&gt;     cat $datafile &gt;&gt; all.pdb\n&gt; done\nWhat is the difference between the two loops below, and which one would we want to run?\n# Version 1\n$ for datafile in *.pdb\n&gt; do\n&gt;     echo cat $datafile &gt;&gt; all.pdb\n&gt; done\n# Version 2\n$ for datafile in *.pdb\n&gt; do\n&gt;     echo \"cat $datafile &gt;&gt; all.pdb\"\n&gt; done\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe second version is the one we want to run. This prints to screen everything enclosed in the quote marks, expanding the loop variable name because we have prefixed it with a dollar sign. It also does not modify nor create the file all.pdb, as the &gt;&gt; is treated literally as part of a string rather than as a redirection instruction.\nThe first version appends the output from the command echo cat $datafile to the file, all.pdb. This file will just contain the list; cat cubane.pdb, cat ethane.pdb, cat methane.pdb etc.\nTry both versions for yourself to see the output! Be sure to open the all.pdb file to view its contents.\n\n\n\n\n\n\n\n\n\nNested Loops\n\n\n\nSuppose we want to set up a directory structure to organize some experiments measuring reaction rate constants with different compounds and different temperatures. What would be the result of the following code:\n$ for species in cubane ethane methane\n&gt; do\n&gt;     for temperature in 25 30 37 40\n&gt;     do\n&gt;         mkdir $species-$temperature\n&gt;     done\n&gt; done\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe have a nested loop, i.e. contained within another loop, so for each species in the outer loop, the inner loop (the nested loop) iterates over the list of temperatures, and creates a new directory for each combination.\nTry running the code for yourself to see which directories are created!\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nA for loop repeats commands once for every thing in a list.\nEvery for loop needs a variable to refer to the thing it is currently operating on.\nUse $name to expand a variable (i.e., get its value). ${name} can also be used.\nDo not use spaces, quotes, or wildcard characters such as ’*’ or ‘?’ in filenames, as it complicates variable expansion.\nGive files consistent names that are easy to match with wildcard patterns to make it easy to select them for looping.\nUse the up-arrow key to scroll up through previous commands to edit and repeat them.\nUse Ctrl+R to search through the previously entered commands.\nUse history to display recent commands, and ![number] to repeat a command by number.\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/07-script.html",
    "href": "episodes/07-script.html",
    "title": "Shell Scripts",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 30\nExercises: 15\nQuestions:\n\nHow can I save and re-use commands?\n\nObjectives:\n\nWrite a shell script that runs a command or series of commands for a fixed set of files.\nRun a shell script from the command line.\nWrite a shell script that operates on a set of files defined by the user on the command line.\nCreate pipelines that include shell scripts you, and others, have written.\nWe are finally ready to see what makes the shell such a powerful programming environment. We are going to take the commands we repeat frequently and save them in files so that we can re-run all those operations again later by typing a single command. For historical reasons, a bunch of commands saved in a file is usually called a shell script, but make no mistake — these are actually small programs.\nNot only will writing shell scripts make your work faster, but also you won’t have to retype the same commands over and over again. It will also make it more accurate (fewer chances for typos) and more reproducible. If you come back to your work later (or if someone else finds your work and wants to build on it), you will be able to reproduce the same results simply by running your script, rather than having to remember or retype a long list of commands.\nLet’s start by going back to alkanes/ and creating a new file, middle.sh which will become our shell script:\nThe command nano middle.sh opens the file middle.sh within the text editor ‘nano’ (which runs within the shell). If the file does not exist, it will be created. We can use the text editor to directly edit the file by inserting the following line:\nThis is a variation on the pipe we constructed earlier, which selects lines 11-15 of the file octane.pdb. Remember, we are not running it as a command just yet; we are only incorporating the commands in a file.\nThen we save the file (Ctrl-O in nano) and exit the text editor (Ctrl-X in nano). Check that the directory alkanes now contains a file called middle.sh.\nOnce we have saved the file, we can ask the shell to execute the commands it contains. Our shell is called bash, so we run the following command:\nSure enough, our script’s output is exactly what we would get if we ran that pipeline directly.\nWhat if we want to select lines from an arbitrary file? We could edit middle.sh each time to change the filename, but that would probably take longer than typing the command out again in the shell and executing it with a new file name. Instead, let’s edit middle.sh and make it more versatile:\nNow, within “nano”, replace the text octane.pdb with the special variable called $1:\nInside a shell script, $1 means ‘the first filename (or other argument) on the command line’. We can now run our script like this:\nor on a different file like this:\nCurrently, we need to edit middle.sh each time we want to adjust the range of lines that is returned. Let’s fix that by configuring our script to instead use three command-line arguments. After the first command-line argument ($1), each additional argument that we provide will be accessible via the special variables $1, $2, $3, which refer to the first, second, third command-line arguments, respectively.\nKnowing this, we can use additional arguments to define the range of lines to be passed to head and tail respectively:\nWe can now run:\nBy changing the arguments to our command, we can change our script’s behaviour:\nThis works, but it may take the next person who reads middle.sh a moment to figure out what it does. We can improve our script by adding some comments at the top:\nA comment starts with a # character and runs to the end of the line. The computer ignores comments, but they’re invaluable for helping people (including your future self) understand and use scripts. The only caveat is that each time you modify the script, you should check that the comment is still accurate. An explanation that sends the reader in the wrong direction is worse than none at all.\nWhat if we want to process many files in a single pipeline? For example, if we want to sort our .pdb files by length, we would type:\nbecause wc -l lists the number of lines in the files (recall that wc stands for ‘word count’, adding the -l option means ‘count lines’ instead) and sort -n sorts things numerically. We could put this in a file, but then it would only ever sort a list of .pdb files in the current directory. If we want to be able to get a sorted list of other kinds of files, we need a way to get all those names into the script. We can’t use $1, $2, and so on because we don’t know how many files there are. Instead, we use the special variable $@, which means, ‘All of the command-line arguments to the shell script’. We also should put $@ inside double-quotes to handle the case of arguments containing spaces (\"$@\" is special syntax and is equivalent to \"$1\" \"$2\" …).\nHere’s an example:\nSuppose we have just run a series of commands that did something useful — for example, creating a graph we’d like to use in a paper. We’d like to be able to re-create the graph later if we need to, so we want to save the commands in a file. Instead of typing them in again (and potentially getting them wrong) we can do this:\nThe file redo-figure-3.sh now contains:\nAfter a moment’s work in an editor to remove the serial numbers on the commands, and to remove the final line where we called the history command, we have a completely accurate record of how we created that figure.\nIn practice, most people develop shell scripts by running commands at the shell prompt a few times to make sure they’re doing the right thing, then saving them in a file for re-use. This style of work allows people to recycle what they discover about their data and their workflow with one call to history and a bit of editing to clean up the output and save it as a shell script."
  },
  {
    "objectID": "episodes/07-script.html#nelles-pipeline-creating-a-script",
    "href": "episodes/07-script.html#nelles-pipeline-creating-a-script",
    "title": "Shell Scripts",
    "section": "Nelle’s Pipeline: Creating a Script",
    "text": "Nelle’s Pipeline: Creating a Script\nNelle’s supervisor insisted that all her analytics must be reproducible. The easiest way to capture all the steps is in a script.\nFirst we return to Nelle’s project directory:\n$ cd ../../north-pacific-gyre/\nShe creates a file using nano …\n$ nano do-stats.sh\n…which contains the following:\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone\nShe saves this in a file called do-stats.sh so that she can now re-do the first stage of her analysis by typing:\n$ bash do-stats.sh NENE*A.txt NENE*B.txt\nShe can also do this:\n$ bash do-stats.sh NENE*A.txt NENE*B.txt | wc -l\nso that the output is just the number of files processed rather than the names of the files that were processed.\nOne thing to note about Nelle’s script is that it lets the person running it decide what files to process. She could have written it as:\n# Calculate stats for Site A and Site B data files.\nfor datafile in NENE*A.txt NENE*B.txt\ndo\n    echo $datafile\n    bash goostats.sh $datafile stats-$datafile\ndone\nThe advantage is that this always selects the right files: she doesn’t have to remember to exclude the ‘Z’ files. The disadvantage is that it always selects just those files — she can’t run it on all files (including the ‘Z’ files), or on the ‘G’ or ‘H’ files her colleagues in Antarctica are producing, without editing the script. If she wanted to be more adventurous, she could modify her script to check for command-line arguments, and use NENE*A.txt NENE*B.txt if none were provided. Of course, this introduces another tradeoff between flexibility and complexity.\n\n\n\n\n\n\nVariables in Shell Scripts\n\n\n\nIn the alkanes directory, imagine you have a shell script called script.sh containing the following commands:\nhead -n $2 $1\ntail -n $3 $1\nWhile you are in the alkanes directory, you type the following command:\n$ bash script.sh '*.pdb' 1 1\nWhich of the following outputs would you expect to see?\n\nAll of the lines between the first and the last lines of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file ending in .pdb in the alkanes directory\nThe first and the last line of each file in the alkanes directory\nAn error because of the quotes around *.pdb\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe correct answer is 2.\nThe special variables $1, $2 and $3 represent the command line arguments given to the script, such that the commands run are:\n$ head -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\n$ tail -n 1 cubane.pdb ethane.pdb octane.pdb pentane.pdb propane.pdb\nThe shell does not expand '*.pdb' because it is enclosed by quote marks. As such, the first argument to the script is '*.pdb' which gets expanded within the script by head and tail.\n\n\n\n\n\n\n\n\n\nFind the Longest File With a Given Extension\n\n\n\nWrite a shell script called longest.sh that takes the name of a directory and a filename extension as its arguments, and prints out the name of the file with the most lines in that directory with that extension. For example:\n$ bash longest.sh shell-lesson-data/exercise-data/alkanes pdb\nwould print the name of the .pdb file in shell-lesson-data/exercise-data/alkanes that has the most lines.\nFeel free to test your script on another directory e.g.\n$ bash longest.sh shell-lesson-data/exercise-data/writing txt\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n# Shell script which takes two arguments:\n#    1. a directory name\n#    2. a file extension\n# and prints the name of the file in that directory\n# with the most lines which matches the file extension.\n\nwc -l $1/*.$2 | sort -n | tail -n 2 | head -n 1\nThe first part of the pipeline, wc -l $1/*.$2 | sort -n, counts the lines in each file and sorts them numerically (largest last). When there’s more than one file, wc also outputs a final summary line, giving the total number of lines across all files. We use tail -n 2 | head -n 1 to throw away this last line.\nWith wc -l $1/*.$2 | sort -n | tail -n 1 we’ll see the final summary line: we can build our pipeline up in pieces to be sure we understand the output.\n\n\n\n\n\n\n\n\n\nScript Reading Comprehension\n\n\n\nFor this question, consider the shell-lesson-data/exercise-data/alkanes directory once again. This contains a number of .pdb files in addition to any other files you may have created. Explain what each of the following three scripts would do when run as bash script1.sh *.pdb, bash script2.sh *.pdb, and bash script3.sh *.pdb respectively.\n# Script 1\necho *.*\n# Script 2\nfor filename in $1 $2 $3\ndo\n    cat $filename\ndone\n# Script 3\necho $@.pdb\n\n\n\n\n\n\n\n\nSolutions\n\n\n\n\n\nIn each case, the shell expands the wildcard in *.pdb before passing the resulting list of file names as arguments to the script.\nScript 1 would print out a list of all files containing a dot in their name. The arguments passed to the script are not actually used anywhere in the script.\nScript 2 would print the contents of the first 3 files with a .pdb file extension. $1, $2, and $3 refer to the first, second, and third argument respectively.\nScript 3 would print all the arguments to the script (i.e. all the .pdb files), followed by .pdb. $@ refers to all the arguments given to a shell script.\ncubane.pdb ethane.pdb methane.pdb octane.pdb pentane.pdb propane.pdb.pdb\n\n\n\n\n\n\n\n\n\nDebugging Scripts\n\n\n\nSuppose you have saved the following script in a file called do-errors.sh in Nelle’s north-pacific-gyre directory:\n# Calculate stats for data files.\nfor datafile in \"$@\"\ndo\n    echo $datfile\n    bash goostats.sh $datafile stats-$datafile\ndone\nWhen you run it from the north-pacific-gyre directory:\n$ bash do-errors.sh NENE*A.txt NENE*B.txt\nthe output is blank. To figure out why, re-run the script using the -x option:\n$ bash -x do-errors.sh NENE*A.txt NENE*B.txt\nWhat is the output showing you? Which line is responsible for the error?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe -x option causes bash to run in debug mode. This prints out each command as it is run, which will help you to locate errors. In this example, we can see that echo isn’t printing anything. We have made a typo in the loop variable name, and the variable datfile doesn’t exist, hence returning an empty string.\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nSave commands in files (usually called shell scripts) for re-use.\nbash [filename] runs the commands saved in a file.\n$@ refers to all of a shell script’s command-line arguments.\n$1, $2, etc., refer to the first command-line argument, the second command-line argument, etc.\nPlace variables in quotes if the values might have spaces in them.\nLetting users decide what files to process is more flexible and more consistent with built-in Unix commands.\n\n\n\n\n\n\n← Previous\n\n\nNext →"
  },
  {
    "objectID": "episodes/09-awk.html",
    "href": "episodes/09-awk.html",
    "title": "AWK for Text Processing",
    "section": "",
    "text": "Overview\n\n\n\n\nTeaching: 20\nExercises: 5\nQuestions:\n\nHow do I print specific columns from a text table?\nHow can I use patterns to select only certain lines in a file?\nHow do I count lines or matched lines in a file?\n\nObjectives:\n\nSelect and print fields with $0, $1, $2, $NF, and NF.\nUse a field separator with -F to handle CSV input.\nMatch lines using simple regex like /^ATOM/.\nCount total or matching lines with a counter and the END block.\nExplain the difference between wc -l and awk 'END {print NR}' for line counting.\nIf we need to count the number of lines in a file, we can use the previously showed command for word counting wc\nAs you probably remember, -l is an option that asks for the number of lines only.\nHowever, wc counts the number of newlines in the file, if the last line does not contain a carriage return (i.e. there is no emptyline at the end of the file), the result is going be the actual number of lines minus one.\nA workaround is to use awk. awk is command line program that takes as input a set of instructions and one or more files. The instructions are executed on each line of the input file(s).\nThe instructions are enclosed in single quotes or they can be read from a file.\nExample:\nThis command has the same output of cat: it prints each line from the example.txt file.\nThe structure of the instruction is the following: - curly braces surround the set of instructions - print is the instruction that sends its arguments to the terminal - $0 is a variable, it means “the content of the current line”\nAs you can see, the file contains a table.\nAwk automatically splits the processed line by looking at spaces: in our case it has knowledge of the different columns in the table.\nEach column value for the current line is stored into a variable: $1 for the first column, $2 for the second and so on.\nSo, if we like to print only the second column from the table, we execute\nWe can also print more than one value, or add text to the printed line:\nThe comma puts a space between the printed values. Strings of text should be enclosed in double quotes. In this case we are printing the text “chr”, the second and the fourth column for each row in the table.\nSo, $0 is the whole line, $1 the first field, $2 the second and so on. What if we want to print the last column, but we don’t know its number? Maybe it is a huge table, or maybe different lines have a different number of columns.\nAwk helps us thanks to the variable NF. NF stores the number of fields (our columns) in the row. Let’s see for our table:\nWe can see that some lines contain 6 fields while others contain 7 of them. Since NF is the number of the last field, $NF contains its value.\nTo specify the field separator, we should provide it at command line like:\nIn this case, we are printing the second field in each line, using comma as separator. Please notice that the character space is now part of the field value, since it is no longer the separator."
  },
  {
    "objectID": "episodes/09-awk.html#pattern-action-model",
    "href": "episodes/09-awk.html#pattern-action-model",
    "title": "AWK for Text Processing",
    "section": "Pattern-Action Model",
    "text": "Pattern-Action Model\nAWK reads a file line by line, splits each line into fields, and then applies pattern { action } rules.\nMaybe we would like to perform different instruction on different lines. Awk allows you to specify a matching pattern, like the command grep does.\nLet’s look at the file content\n$ awk '{print $0}' example.pdb\nIt seems an abriged PDB file. If we would like to print only lines starting with the word “ATOM”, we type:\nawk '/^ATOM/ {print $0}' example.pdb\nIn this case, we specify the pattern before the instructions: only lines starting with the text “ATOM”. As you remember, ^ means “at the beginning of the line”.\nWe can specify more that one pattern:\nawk '/^ATOM/ {print $7,$8,$9} /^HEADER/ {print $NF}' example.pdb\nIn this case, we are printing the spatial coordinates of each atom.\nThe special block END { ... } runs after all lines are processed. It’s ideal for printing totals collected while scanning.\nNR is the current line number. After the last line, NR equals the number of lines read:\nawk 'END { print NR }' example.txt\nThis avoids the missing final newline issue that can affect wc -l (if the last line lacks a trailing newline, wc -l may under‑count by 1).\nTo Count only matching lines, increment a counter inside the pattern, then report it in END:\nawk '/^ATOM/ { count++ } END { print \"ATOM lines:\", count+0 }' example.pdb\n\n/^ATOM/ matches lines that begin with ATOM.\ncount++ adds 1 for each match.\nIn END, we print the total. count+0 safely prints 0 if there were no matches.\n\n\n\n\n\n\n\nChallenge: Counting and Selecting (Simple)\n\n\n\nUsing only the ideas covered above (field selection, patterns, NF, and END):\n\nWrite an awk command that prints the number of lines in example.txt.\nWrite an awk command that prints the number of lines in example.pdb that start with ATOM.\nWrite an awk command that prints the last field of each ATOM line in example.pdb (just the values, one per line).\n\nBonus (optional): Print both the count of ATOM lines and, at the end, the total number of characters across all those last fields.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nTotal lines (robust):\n\nawk 'END { print NR }' example.txt\n\nCount lines starting with ATOM:\n\nawk '/^ATOM/ { c++ } END { print c+0 }' example.pdb\n\nLast field of each ATOM line:\n\nawk '/^ATOM/ { print $NF }' example.pdb\nBonus (count and accumulate character lengths of last field):\nawk '/^ATOM/ { c++; total += length($NF) } END { print \"ATOM lines:\", c+0; print \"Total chars in last field:\", total+0 }' example.pdb\nExplanation: - NR gives total lines after reading the file. - /^ATOM/ pattern restricts actions to lines starting with ATOM. - $NF is the last field; length($NF) measures its size. - Counters (c, total) are printed in END.\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\n$0 is the whole line; $1..$NF are its fields; NF is the count of fields.\n-F sets the field separator (comma, tab, etc.).\nUse /pattern/ { action } to run code only on matching lines.\nIncrement a variable inside the action and print totals in END {}.\nNR gives total lines read; wc -l can undercount if last newline is missing.\n\n\n\n\n\n\n← Previous"
  }
]